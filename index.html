<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="./kimsze_sharp16.ico?v=20260111a" sizes="any">
  <link rel="shortcut icon" href="./kimsze_sharp16.ico?v=20260111a">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>One Minute Dash ‚Äî Phonograms ‚Ä¢ HFW ‚Ä¢ Words (xAPI Base)</title>

  <!-- xAPI base scripts (UNCHANGED) -->
  <script>
    window.ACTIVITY_ID = "https://github.com/limkimsze-maker/consonants/blob/915c8b275fbde80b1a569ba601ab800869d6e313/ActivityID";
  </script>
  <script src="xapiwrapper.min.js"></script>
  <script src="index.js" defer></script>

  <!-- New-Session Clear Kit (drop-in) -->
  <script>
  (function (global){
    const Kit = {
      init(opts = {}) {
        const ACTIVITY_ID = String(opts.activityId || global.ACTIVITY_ID || location.href);
        const QS = new URLSearchParams(location.search);
        const salt = (typeof opts.scopeSalt === 'function') ? (opts.scopeSalt(QS) || '') : (opts.scopeSalt || '');
        const baseQS = QS.get('attempt') || QS.get('run') || QS.get('session') || QS.toString() || 'noqs';
        const CURR_SCOPE = `${ACTIVITY_ID}::${salt}::${baseQS}`;
        const SCOPE_KEY  = `sls_scope::${ACTIVITY_ID}`;
        const resetParam = opts.resetParam || 'reset';
        const FORCE = QS.has(resetParam) || QS.has('newSession');

        let prev = null;
        try { prev = localStorage.getItem(SCOPE_KEY); } catch (e) {}

        const isNew = FORCE || prev !== CURR_SCOPE;
        if (isNew) {
          if (opts.clickButtonId) {
            const btn = document.getElementById(opts.clickButtonId);
            if (btn) {
              try { btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true })); } catch (e) {}
            }
          }
          if (typeof opts.onNewSession === 'function') {
            try { opts.onNewSession(); } catch (e) {}
          }
          if (opts.pushZero !== false) {
            const payload = { score: 0 };
            try { if (typeof global.storeState === 'function') global.storeState(payload); } catch (e) {}
            try { if (typeof global.sendState  === 'function') global.sendState(payload);  } catch (e) {}
          }
          try { localStorage.setItem(SCOPE_KEY, CURR_SCOPE); } catch (e) {}
        }
        return { isNewAssignment: isNew, scope: CURR_SCOPE };
      }
    };
    global.NewSessionClearKit = Kit;
  })(window);
  </script>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;600;700;800;900&display=swap" rel="stylesheet" />

  <style>
    :root{
      --itembg:#eaf2ff;
      --itemline:#d6e6ff;
      --bg:#d1d5db;
      --card:#e5e7eb;
      --grid:#94a3b8;

      --paper:#e9fbe9;
      --paper2:#f3fdf3;

      --ink:#111827;
      --muted:#374151;
      --line:#e9eef7;
      --brand:#2563eb;
      --good:#16a34a;
      --bad:#e11d48;
      --warn:#d97706;
      --pill:#111827;

      --radius:16px;
      --shadow: 0 16px 40px rgba(0,0,0,.08);

      --vowel:#dc2626;
      --prefix:#16a34a;
      --suffix:#2563eb;
    }

    *{ box-sizing:border-box; }

    body{
      background:var(--bg);
      color:var(--ink);
      font-family:"Lexend", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size:18px;
      line-height:1.6;
      letter-spacing:0.005em;
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;

      margin:0;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      min-height:100vh;
      padding:16px;
      gap:20px;
    }

    @media (max-width:520px){
      body{ font-size:17px; }
    }

    :focus-visible{
      outline: 3px solid rgba(37,99,235,.35);
      outline-offset: 3px;
      border-radius: 10px;
    }

    .container{
      background:var(--paper);
      padding:10px;
      border-radius:8px;
      box-shadow:0 0 5px rgba(0,0,0,.08);
      width:590px;
      height:470px;
      overflow:auto;
    }
    #xapiBase{ display:none; }

    #omdApp{
      width:min(1200px, 95vw);
      background:var(--card);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:22px 22px 26px;
      position:relative;
    }

    header{
      display:grid;
      gap:8px;
      margin-bottom:12px;
    }
    header h1{
      margin:0;
      font-size:24px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
    }

    header p{
      margin:0;
      color:var(--muted);
      font-size:15px;
      line-height:1.6;
      max-width:65ch;
    }

    .topbar{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top:6px;
    }

    .statusBadge{
      background:#0f172a;
      color:#fff;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
      white-space:nowrap;
      max-width:75ch;
      overflow:hidden;
      text-overflow:ellipsis;
      display:none;
    }

    .row{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
      align-items:start;
    }

    .panel{
      background:var(--paper2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px;
      overflow:auto;
      max-height:70vh;
    }

    .control{
      background:var(--paper);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      margin-bottom:12px;
    }
    .control h3{
      margin:0 0 8px;
      font-size:16px;
    }

    .hint{
      font-size:13px;
      color:#4b5563;
      margin-top:6px;
      line-height:1.55;
      max-width:65ch;
    }

    .row-small{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      border-radius:12px;
      padding:10px 14px;
      font-weight:900;
      color:#fff;
      transition:transform .06s ease, box-shadow .18s ease, filter .18s ease;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .btn:active{ transform:translateY(1px); box-shadow: 0 6px 14px rgba(0,0,0,.10); }
    .btn.ghost{
      background:var(--paper);
      color:var(--brand);
      border:1px solid #cfe1ff;
      box-shadow:none;
    }
    .btn.ok{ background:var(--good); }
    .btn.bad{ background:var(--bad); }
    .btn.warn{ background:var(--warn); }
    .btn.primary{ background:var(--brand); }
    .btn.small{ padding:8px 10px; font-size:13px; border-radius:10px; }
.btn.big{
  padding:14px 18px;
  font-size:18px;
  border-radius:14px;
}

    .btn.disabled{ opacity:.55; pointer-events:none; }

    .seg{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .seg button{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--paper);
      color:var(--ink);
      font-weight:900;
      cursor:pointer;
    }
   .seg button.active{
  border-color:#fecaca;
  background:#fee2e2;
  color:#7f1d1d;
}


    select, input[type="number"], textarea{
      font-family:inherit;
      font-size:15px;
    }
    select, input[type="number"]{
      width:100%;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:var(--paper);
      color:var(--ink);
      font-weight:700;
    }
    textarea{
      width:100%;
      min-height:96px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      resize:vertical;
      font-weight:700;
      background:var(--paper);
      color:var(--ink);
    }

    .pillRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      background:var(--pill);
      color:#fff;
      font-size:13px;
      font-weight:800;
    }
    .pill.good{ background:#065f46; }
    .pill.bad{ background:#991b1b; }
    .pill.neutral{ background:#111827; }

    .vowel{ color:var(--vowel); }
    .cons{ color:#000; }
    .pre{ color:var(--prefix); }
    .suf{ color:var(--suffix); }

    .sidPill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #e2e8f0;
      background:var(--paper2);
      color:#0f172a;
      font-weight:1000;
      font-size:13px;
      margin-right:12px;
      letter-spacing:.2px;
      flex:0 0 auto;
    }
    .sidPill.small{
      padding:4px 8px;
      font-size:12px;
      margin-right:10px;
    }

    .wordText .sidPill,
    .pill .sidPill{
      position:static;
      margin-right:10px;
    }

    .view{ display:none; }
    .view.active{ display:block; }

    .dashCard{
      background:var(--card);
      border:1px solid #f1f1f4;
      border-radius:18px;
      padding:18px;
      display:grid;
      gap:12px;
      justify-items:center;
      text-align:center;
    }

    .timer{
      font-size:44px;
      font-weight:1000;
      letter-spacing:1px;
      color:#0f172a;
      min-width:140px;
      text-align:center;
    }
    .timer.soon{ color:#b45309; }
    .timer.zero{ color:#991b1b; }

    .bigItem{
      font-size:clamp(54px, 10vw, 140px);
      font-weight:1000;
      letter-spacing:1.5px;
      padding:10px 18px;
      border-radius:16px;
      border:1px solid var(--itemline);
      background:var(--itembg);
      line-height:1;
      color:#000;
      min-width:min(520px, 92%);
      display:flex;
      justify-content:center;
      align-items:center;
      gap:0;
      flex-wrap:wrap;
    }
    .bigItem .sp{ width:12px; display:inline-block; }

    .bigItem.hasSid{
      display:block;
      position:relative;
      min-width:min(520px, 92%);
      white-space:nowrap;
      overflow:hidden;
      text-align:center;
      line-height:1.05;
      letter-spacing:1px;
      padding:46px 18px 16px;
      font-size:clamp(44px, 9vw, 120px);
    }
    .bigItem.hasSid .sidPill{
      position:absolute;
      left:14px;
      top:12px;
      margin:0;
    }

    .metaLine{
      color:#4b5563;
      font-size:14px;
      font-weight:700;
      max-width:65ch;
    }
    .kpi{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      color:#0f172a;
      font-size:13px;
    }
    .kpi span{
      background:var(--paper2);
      border:1px solid #e2e8f0;
      border-radius:999px;
      padding:6px 10px;
      font-weight:900;
    }

    /* ‚úÖ Chart should fit panel width (no horizontal scroll) */
.chartWrap{ overflow:hidden; }

table{
  border-collapse:separate;
  border-spacing:0;
  width:100%;
  font-size:12px;              /* slightly smaller to fit */
  background:var(--paper);
  border:1px solid var(--grid);
  border-radius:14px;
  overflow:hidden;

  table-layout:fixed;          /* force columns to share width */
}

th, td{
  padding:6px 6px;             /* tighter cells */
  border-bottom:1px solid var(--grid);
  border-right:1px solid var(--grid);
  text-align:center;
  vertical-align:middle;

  white-space:normal;          /* allow wrapping */
  overflow:hidden;
  text-overflow:ellipsis;      /* prevents spill if still too tight */
}

/* Make the first columns readable but still flexible */
th.left, td.left{
  text-align:left;
  white-space:nowrap;          /* keep ‚ÄúCycle 10‚Äù on one line */
}


    th{
      background:#eff6ff;
      color:#1e3a8a;
      font-weight:1000;
    }
    th{ border-bottom:2px solid var(--grid); }
    tr:last-child td{ border-bottom:none; }
    td:last-child, th:last-child{ border-right:none; }
    .left{ text-align:left; }
    .typeCell{
      font-weight:1000;
      color:#111827;
      background:var(--paper2);
    }
    .mutedCell{ color:#94a3b8; }

    .historyCard{
      display:grid;
      gap:8px;
    }
    .histItem{
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      background:var(--paper);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .histItem b{ font-weight:1000; }
    .histItem small{ color:#6b7280; font-weight:700; line-height:1.45; }
    .histItem .rightSide{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }

    .review-grid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(220px,1fr)); gap:12px; }
    .review-card{
      background:var(--paper);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      text-align:center;
      display:grid;
      gap:10px;
    }
    .review-card .bigItem{
      font-size:52px;
      min-width:auto;
      width:100%;
      padding:10px 12px;
      letter-spacing:1px;
    }
    .review-card .bigItem.hasSid{
      padding:42px 12px 14px;
      font-size:48px;
    }
    .review-card .bigItem.hasSid .sidPill{
      left:12px;
      top:10px;
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--paper);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      color:#111827;
    }
    .toggle .dot{
      width:10px; height:10px; border-radius:999px;
      background:#94a3b8;
    }
    .toggle.on{ border-color:#bbf7d0; background:#ecfdf5; color:#065f46; }
    .toggle.on .dot{ background:#16a34a; }

    .wordsList{
      display:grid;
      gap:10px;
      margin-top:10px;
    }
    .wordRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-start;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:var(--paper2);
    }
    .wordText{
      font-size:20px;
      font-weight:1000;
      letter-spacing:.4px;
      display:flex;
      align-items:center;
      flex-wrap:wrap;
    }

    .credit{
      margin-top:10px;
      color:#6b7280;
      font-size:12px;
      text-align:center;
      font-weight:700;
      line-height:1.45;
    }

    #player{ position:fixed; left:12px; bottom:12px; width:280px; display:none; }

    #fxOverlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background:rgba(15, 23, 42, .55);
      z-index:99999;
      pointer-events:none;
    }
    #fxOverlay .card{
      pointer-events:none;
      background:var(--paper);
      border-radius:18px;
      border:1px solid #e2e8f0;
      box-shadow: 0 20px 60px rgba(0,0,0,.22);
      padding:18px 20px;
      width:min(520px, 92vw);
      text-align:center;
    }
    #fxOverlay .title{
      font-weight:1000;
      font-size:18px;
      color:#0f172a;
      margin:0 0 6px;
    }
    #fxOverlay .sub{
      margin:0;
      color:#64748b;
      font-weight:800;
      font-size:13px;
    }
    #confettiCanvas{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:none;
      z-index:99998;
      pointer-events:none;
    }

    @media (max-width: 980px){
      .row{ grid-template-columns: 1fr; }
      .bigItem{ min-width:auto; width:100%; }
      .bigItem.hasSid{ min-width:auto; width:100%; }
      header p{ max-width: 60ch; }
    }
  </style>

  <script src="https://cdn.counter.dev/script.js" data-id="825e93b6-ce99-40ef-8bcc-125f13297433" data-utcoffset="8"></script>
</head>

<body>
  <canvas id="confettiCanvas"></canvas>
  <div id="fxOverlay" aria-hidden="true">
    <div class="card">
      <p class="title" id="fxTitle">Drumroll‚Ä¶</p>
      <p class="sub" id="fxSub">Get ready! üéâ</p>
    </div>
  </div>

  <div id="xapiBase" class="container">
    <p class="center"><strong>HTML5 Interactive</strong></p>
    <div class="center">
      <label for="score-input">Score:</label>
      <input type="text" id="score-input" />
      <label for="feedback-input">Feedback:</label>
      <input type="text" id="feedback-input" placeholder="Enter feedback" />
    </div>
    <div id="criteria-container" class="center"></div>
    <div class="center">
      <button id="add-criteria-button">Add Rubric Criteria</button>
    </div>
    <div class="center">
      <button id="save-store">Send/Save</button>
      <button id="clear-inputs">Clear</button>
    </div>
    <div class="output-container">
      <pre id="result"></pre>
      <hr class="separator" />
      <pre id="getState"></pre>
      <hr class="separator" />
      <pre id="questionId"></pre>
      <pre id="userId"></pre>
      <pre id="cookieId"></pre>
      <a id="activityLink" href="https://github.com/limkimsze-maker/consonants/blob/915c8b275fbde80b1a569ba601ab800869d6e313/ActivityID" target="_blank" rel="noopener">ActivityID</a>
    </div>
  </div>

  <div id="omdApp">
    <header>
      <h1>üèÉ‚Äç‚ôÇÔ∏è One Minute Dash</h1>
      <p>
        <b>a)</b> Set target with students ‚Üí <b>b)</b> Read as many as possible in 1 minute ‚Üí <b>c)</b> Review errors ‚Üí
        <b>d)</b> Count correct ‚Üí <b>e)</b> Read remaining items.
      </p>

      <div class="topbar">
        <div class="row-small">
          <div id="soundToggle" class="toggle" role="switch" aria-checked="false" tabindex="0" title="Sound is OFF by default">
            <span class="dot" aria-hidden="true"></span>
            <span id="soundLabel">Sound: OFF</span>
          </div>

          <button class="btn ghost small" id="exportBtn" type="button">Download JSON</button>
          <button class="btn ghost small" id="importBtn" type="button">Import JSON</button>
          <button class="btn warn small" id="clearHistoryBtn" type="button">Clear history</button>

          <button class="btn ghost small" id="newSessionBtn" type="button">New session (clear SLS attempt)</button>
          <a class="btn ghost small" href="https://limkimsze-maker.github.io/P3_SDR_Spelling/" target="_blank" rel="noopener">SDR Spelling</a>

          <input id="importFile" type="file" accept="application/json" class="hidden" style="display:none;">
        </div>

        <div id="statusBadge" class="statusBadge" aria-live="polite"></div>
      </div>
    </header>

    <section id="setupView" class="view active">
      <div class="row">
        <section class="controls">
          <div class="control">
  <h3>0) Mode</h3>
  <div class="seg" aria-label="Select app mode">
    <button id="appDashBtn" type="button" class="active">üèÉ One Minute Dash</button>
    <button id="appFocusBtn" type="button">üéØ Focus of the Day</button>
  </div>
  <div class="hint">Pick a mode first. Selected mode will be highlighted in red.</div>
</div>

<div class="control">
  <h3>1) Category</h3>
  <div class="seg" aria-label="Select item type">
    <button id="modeP" type="button" class="active">P ‚Äî Phonograms</button>
    <button id="modeH" type="button">HFW ‚Äî High Frequency Words</button>
    <button id="modeW" type="button">Words</button>
  </div>
  <div class="hint" id="modeHint">
    Phonograms + HFW use a cumulative scope (all taught up to that point). Words uses <b>current session + previous 2 sessions</b>.
  </div>
</div>


          <div class="control">
            <h3>2) We are at (Cycle & Session)</h3>
            <div class="row-small">
  <div style="flex:1; min-width:140px;">
    <label class="hint" for="cycleSel">Cycle</label>
    <select id="cycleSel"></select>
  </div>
  <div style="flex:1; min-width:140px;">
    <label class="hint" for="sessSel">Session</label>
    <select id="sessSel"></select>
  </div>
</div>

            <div class="hint" id="scopeHint">‚Äî</div>
          </div>

          <div class="control" id="focusOnly" style="display:none;">
  <h3>2) Focus of the Day</h3>
  <div class="row-small" style="justify-content:center;">
    <button class="btn primary big" id="focusStartBtn" type="button" style="min-width:260px;">
      Start Focus of the Day
    </button>
  </div>
  <div class="hint" style="text-align:center;">
    Choose Category + Cycle + Session above, then press Start.<br>
    You will get the full list + one-by-one Next/Prev.
  </div>
</div>


          <div class="control" id="hfwEditor" style="display:none;">
            <h3>HFW words for selected Cycle/Session</h3>
            <div class="hint">These are preloaded. You can edit if needed (one per line OR separated by commas), then save.</div>
            <textarea id="hfwText" placeholder="e.g. the&#10;and&#10;is&#10;to"></textarea>
            <div class="row-small" style="margin-top:8px; justify-content:space-between;">
              <div class="hint" id="hfwCountHint">0 words saved for this session</div>
              <button class="btn primary small" id="saveHfwBtn" type="button">Save HFW list</button>
            </div>
          </div>

          <div class="control" id="wordsPanel" style="display:none;">
            <h3>Words database ‚Äî <span id="wordsSidLabel">C1S1</span></h3>
            <div class="hint">
              Each word shows its session tag (e.g., <b>C1S1</b>). ‚ñ∂ uses TTS.
              <span style="color:var(--vowel);font-weight:1000;">Vowels/vowel teams/magic-e/r-controlled/igh</span> are red,
              <span style="color:var(--prefix);font-weight:1000;">prefixes</span> (per lesson) are green,
              <span style="color:var(--suffix);font-weight:1000;">suffixes</span> (per lesson) are blue.
            </div>
            <div id="wordsList" class="wordsList"></div>
          </div>
<div id="dashOnly">

          <div class="control">
            <h3>3) Target</h3>
            <div class="row-small">
              <div style="flex:1; min-width:200px;">
                <label class="hint" for="targetInput">Target number (goal)</label>
                <input type="number" id="targetInput" min="0" value="0" />
              </div>
</div>

              <div style="display:grid; gap:6px; align-content:end;">
                <button class="btn ghost small" id="autoTargetBtn" type="button">Auto = scope size</button>
              </div>
            </div>
            <div class="hint" id="targetHint">‚Äî</div>
          </div>

          <div class="control">
            <h3>4) Timer</h3>
            <div class="row-small">
              <label style="font-weight:900;"><input type="radio" name="timed" value="on" checked> Timer ON (60s)</label>
              <label style="font-weight:900;"><input type="radio" name="timed" value="off"> Timer OFF (own time)</label>
            </div>
            <div class="hint">Chart updates <b>only</b> when Timer is ON.</div>
          </div>

          <div class="control">
            <h3>5) Order</h3>
            <div class="row-small">
              <label style="font-weight:900;"><input type="radio" name="order" value="sequence" checked> Sequence</label>
              <label style="font-weight:900;"><input type="radio" name="order" value="random"> Randomised</label>
            </div>
          </div>

          <div class="control">
            <h3>Start</h3>
            <div class="row-small">
              <button class="btn ok" id="startBtn" type="button">Start</button>
              <button class="btn ghost" id="resetBtn" type="button">Reset selection</button>
            </div>
            <div class="hint" id="startHint">
              Chart tracks Target vs Actual for each Cycle & Session (Timed only). Records are saved locally in this browser.
            </div>
          </div>

          <div class="credit">
            Designed by Lim Kim Sze ¬© 2026.<br>
            (Phonogram audio uses your existing <code>audio/</code> folder if present; HFW tries <code>audio/words/</code> then speech; Words uses <b>TTS</b>.)
          </div>
        </section>

        <section class="panel">
          <h3 style="margin:4px 0 10px;">P3 SDR One Minute Dash Chart (Timed only ‚Äî Target vs Actual)</h3>

          <div class="row-small" style="justify-content:space-between; margin:0 0 10px;">
            <div class="hint" id="chartLockHint" style="margin:0;">Chart: Locked (tap Unlock to edit)</div>
            <div class="row-small" style="gap:8px;">
              <button class="btn ghost small" id="unlockChartBtn" type="button">Unlock chart</button>
              <button class="btn ghost small" id="lockChartBtn" type="button" style="display:none;">Lock</button>
              <button class="btn ghost small" id="clearOverridesBtn" type="button">Clear manual edits</button>
            </div>
          </div>

          <div class="chartWrap" id="chartWrap"></div>

          <hr style="margin:14px 0; border-color:#eef2ff;" />

          <h3 style="margin:4px 0 10px;">Recent records</h3>
          <div id="historyHost" class="historyCard"></div>
        </section>
      </div>
    </section>

    <section id="dayView" class="view">
      <div class="dashCard" style="width:100%;">
        <div class="row-small" style="width:100%; justify-content:space-between; gap:10px;">
          <button class="btn ghost small" id="backFromDay" type="button">‚Üê Back</button>
          <div style="font-weight:1000;" id="dayTitle">‚Äî</div>
          <div class="hint" id="daySub">‚Äî</div>
        </div>

        <div class="bigItem" id="dayBig">‚Äî</div>

        <div class="row-small" style="justify-content:center;">
          <button class="btn ghost small" id="dayPlayBtn" type="button">üîä Play</button>
        </div>

        <div class="row-small" style="justify-content:center; gap:12px;">
          <button class="btn ghost small" id="dayPrevBtn" type="button" style="min-width:140px;">‚óÄ Prev</button>
          <button class="btn primary" id="dayNextBtn" type="button" style="min-width:140px;">Next ‚ñ∂</button>
        </div>

        <div class="hint" id="dayCountHint">‚Äî</div>

        <div class="control" style="width:100%; max-width:980px; margin:0 auto;">
          <h3 style="margin:0 0 8px;" id="dayAllTitle">All items</h3>
          <div id="dayAllHost"></div>
        </div>
      </div>
    </section>

    <section id="dashView" class="view">
      <div class="dashCard">
        <div class="row-small" style="width:100%; justify-content:space-between; gap:10px;">
          <button class="btn ghost small" id="backSetupFromDash" type="button">‚Üê Back</button>
          <div class="timer" id="timerTxt" aria-live="polite">01:00</div>
          <button class="btn ghost small" id="pauseBtn" type="button" title="Pausing stops the timer">Pause</button>
        </div>

        <div class="kpi" id="kpiLine">
          <span>Target: <b id="kpiTarget">0</b></span>
          <span>Correct: <b id="kpiCorrect">0</b></span>
          <span>Wrong: <b id="kpiWrong">0</b></span>
          <span>Attempted: <b id="kpiAttempted">0</b></span>
        </div>

        <div class="metaLine" id="dashMeta">‚Äî</div>

        <div class="bigItem" id="dashItem">‚Äî</div>

        <div class="row-small" style="justify-content:center;">
          <button class="btn ghost small" id="playBtn" type="button">üîä Play</button>
        </div>

        <div class="row-small" style="justify-content:center; gap:12px;">
          <button class="btn ok" id="yesBtn" type="button" style="min-width:140px;">Yes</button>
          <button class="btn bad" id="noBtn" type="button" style="min-width:140px;">No</button>
        </div>

        <div class="hint" id="dashProgress">‚Äî</div>
      </div>
    </section>

    <section id="resultView" class="view">
      <div class="control">
        <h3>Dash summary</h3>
        <p id="summaryLine" style="margin:6px 0 0; font-weight:900;">‚Äî</p>
        <p id="summaryMeta" class="hint" style="margin:6px 0 0;">‚Äî</p>

        <div id="listsWrap" style="display:grid; gap:12px; margin-top:12px;">
          <div>
            <h4 style="margin:0 0 6px;">‚úî Correct</h4>
            <div id="correctList" class="pillRow"></div>
          </div>
          <div>
            <h4 style="margin:0 0 6px;">‚úñ Incorrect (Visual Drill / recap next session)</h4>
            <div id="wrongList" class="pillRow"></div>
          </div>
          <div>
            <h4 style="margin:0 0 6px;">‚è≥ Not attempted (remaining)</h4>
            <div id="remainList" class="pillRow"></div>
          </div>
        </div>

        <div class="row-small" style="margin-top:12px; justify-content:flex-end;">
          <button class="btn primary" id="reviewWrongBtn" type="button">Review wrong items</button>
          <button class="btn ghost" id="readRemainingBtn" type="button">Read remaining (untimed)</button>
          <button class="btn ghost" id="backSetupFromResult" type="button">Back to setup</button>
        </div>

        <div class="hint" style="margin-top:10px;">
          Record storage: saved automatically to this browser (localStorage). Chart uses <b>Timed</b> records only.
        </div>
      </div>
    </section>

    <section id="reviewView" class="view">
      <div class="control">
        <div class="row-small" style="justify-content:space-between;">
          <h3 style="margin:0;">Review wrong items</h3>
          <button class="btn ghost small" id="backToResultFromReview" type="button">‚Üê Back</button>
        </div>
        <p class="hint" style="margin-top:6px;">Tap the item buttons to hear them. Mark as reviewed when ready.</p>
        <div id="reviewGrid" class="review-grid" style="margin-top:10px;"></div>

        <div class="row-small" style="margin-top:12px; justify-content:flex-end;">
          <button class="btn ok" id="finishReviewBtn" type="button">Complete review</button>
        </div>
      </div>
    </section>

    <section id="remainingView" class="view">
      <div class="dashCard">
        <div class="row-small" style="width:100%; justify-content:space-between;">
          <button class="btn ghost small" id="backToResultFromRemaining" type="button">‚Üê Back</button>
          <div style="font-weight:1000;">Read remaining (untimed)</div>
          <div class="hint" id="remainProg">‚Äî</div>
        </div>

        <div class="bigItem" id="remainItem">‚Äî</div>

        <div class="row-small" style="justify-content:center;">
          <button class="btn ghost small" id="remainPlayBtn" type="button">üîä Play</button>
        </div>

        <div class="row-small" style="justify-content:center; gap:12px;">
          <button class="btn ok" id="remainYesBtn" type="button" style="min-width:140px;">Correct</button>
          <button class="btn bad" id="remainNoBtn" type="button" style="min-width:140px;">Wrong</button>
        </div>

        <div class="hint" id="remainHint">Wrong items here will be shown at the end (for recap).</div>
      </div>
    </section>
  </div>

  <audio id="player" preload="auto" playsinline></audio>

  <script>
  (function(){
    const KEY_RECORDS = 'omd_records_v2';
    const KEY_HFW_DB  = 'omd_hfw_db_v1';
    const KEY_SOUND   = 'omd_soundOn_v1';

    const KEY_CHART_OVR    = 'omd_chart_overrides_v1';
    const KEY_CHART_UNLOCK = 'omd_chart_unlocked_v1';

    function pushToXAPI(score, feedback){
      try {
        const sInput = document.getElementById('score-input');
        const fInput = document.getElementById('feedback-input');
        if (sInput) sInput.value = String(score ?? 0);
        if (fInput) fInput.value = String(feedback ?? '');
        if (typeof updateStore === 'function') updateStore();
        else if (typeof storeState === 'function') storeState({ score, feedback });
        const badge = document.getElementById('statusBadge');
        if (badge){
          badge.style.display = 'block';
          badge.textContent = `Saved for SLS ¬∑ Score ${score}${feedback ? ' ¬∑ ' + (feedback.length>60 ? (feedback.slice(0,60)+'‚Ä¶') : feedback) : ''}`;
        }
      } catch(e) {}
    }

    const TOTAL_CYCLES = 18;
    const SESSIONS_PER_CYCLE = 3;

    function makeSessionId(c,s){ return `C${c}S${s}`; }
    function parseSessionId(id){
      const m = String(id||'').match(/^C(\d+)S(\d+)$/);
      return m ? { cycle: parseInt(m[1],10), session: parseInt(m[2],10) } : { cycle: 0, session: 0 };
    }

    const SESSION_ORDER = [];
    for (let c=1; c<=TOTAL_CYCLES; c++){
      for (let s=1; s<=SESSIONS_PER_CYCLE; s++){
        SESSION_ORDER.push(makeSessionId(c,s));
      }
    }

    const DB = [
      { id: "C1S1", title: "C1S1: Review consonant and vowel graphs", items: ["a","e","i","o","u","b","c-hard","d","f","g-hard","h","j","k","l","m","n","p","qu","r","s","t","v","w","x","y","z"] },
      { id: "C1S2", title: "C1S2: Digraphs [ch, sh, th]", items: ["ch","sh","th"] },

      { id: "C2S1", title: "C2S1: Floss rule [-ff, -ll, -ss, -zz]", items: ["-ff","-ll","-ss","-zz"] },
      { id: "C2S2", title: "C2S2: -ck rule", items: ["-ck"] },
      { id: "C2S3", title: "C2S3: -tch rule", items: ["-tch"] },

      { id: "C3S1", title: "C3S1: -dge rule", items: ["dge"] },
      { id: "C3S2", title: "C3S2: Magic-e rule", items: ["a-e","e-e","i-e","o-e","u-e"] },

      { id: "C6S1", title: "C6S1: Consonant -le blends [-ble, -dle]", items: ["-ble","-dle"] },
      { id: "C6S2", title: "C6S2: Consonant -le blends [-ple, -tle, -gle]", items: ["-ple","-tle","-gle"] },
      { id: "C6S3", title: "C6S3: r-controlled vowels [ar, or]", items: ["ar","or"] },

      { id: "C7S1", title: "C7S1: r-controlled vowels [ir, er, ur]", items: ["ir","er","ur"] },
      { id: "C7S2", title: "C7S2: Vowel graphs [y_vowel_sounds]", items: ["y-vowel"] },

      { id: "C8S1", title: "C8S1: Soft ‚Äòc‚Äô & Soft ‚Äòg‚Äô rule", items: ["c-soft","g-soft"] },
      { id: "C8S2", title: "C8S2: Vowel teams [‚Äòay‚Äô, ‚Äòai‚Äô say /ƒÅ/]", items: ["ai","ay"] },

      { id: "C9S1", title: "C9S1: Vowel team [‚Äòee‚Äô says /ƒì/]", items: ["ee"] },
      { id: "C9S2", title: "C9S2: Vowel team [‚Äòea‚Äô says /ƒï/ or /ƒì/]", items: ["ea-short-e","ea"] },
      { id: "C9S3", title: "C9S3: Vowel team [‚Äòie‚Äô says /ƒ´/ or /ƒì/]", items: ["ie"] },

      { id: "C10S1", title: "C10S1: Vowel team [‚Äòei‚Äô says /ƒì/ or /ƒÅ/]", items: ["ei"] },
      { id: "C10S2", title: "C10S2: Vowel team [‚Äòey‚Äô says /ƒÅ/ or /ƒì/]", items: ["ey"] },

      { id: "C11S1", title: "C11S1: Vowel teams [‚Äòoa‚Äô, ‚Äòow‚Äô says /≈ç/]", items: ["oa","ow-long-o"] },
      { id: "C11S2", title: "C11S2: Vowel team [‚Äòoo‚Äô ‚Äî long & short sounds]", items: ["oo"] },
      { id: "C11S3", title: "C11S3: Vowel teams [‚Äòue‚Äô, ‚Äòew‚Äô, ‚Äòui‚Äô say /oo/]", items: ["ue","ew","ui"] },

      { id: "C12S1", title: "C12S1: Vowel teams [‚Äòue‚Äô, ‚Äòew‚Äô say /≈´/]", items: ["ue-u","ew-u"] },
      { id: "C12S2", title: "C12S2: Vowel team [‚Äòaw‚Äô says /aw/]", items: ["aw"] },

      { id: "C13S1", title: "C13S1: Vowel teams [‚Äòou‚Äô, ‚Äòow‚Äô say /ow/]", items: ["ou","ow"] },
      { id: "C13S2", title: "C13S2: Vowel team [‚Äòoi‚Äô, ‚Äòoy‚Äô say /oi/]", items: ["oi","oy"] },
      { id: "C13S3", title: "C13S3: Vowel team [‚Äòigh‚Äô says /ƒ´/]", items: ["igh"] },

      { id: "C14S1", title: "C14S1: Consonant digraph [‚Äòkn‚Äô says /n/]", items: ["kn"] },
      { id: "C14S2", title: "C14S2: Consonant digraph [‚Äòng‚Äô says /≈ã/, ‚Äònk‚Äô says /≈ãk/]", items: ["ng","nk"] },

      { id: "C16S1", title: "C16S1: Plural suffixes ‚Äò-s‚Äô and ‚Äò-es‚Äô", items: ["-s","-es"] },
      { id: "C16S2", title: "C16S2: Past Tense Suffix ‚Äò-ed‚Äô", items: ["-ed"] },
      { id: "C16S3", title: "C16S3: Prefixes ‚Äòun-‚Äô and ‚Äòin-'", items: ["un-","in-"] },

      { id: "C17S1", title: "C17S1: Suffixes ‚Äò-ing‚Äô and ‚Äò-ful‚Äô", items: ["-ing","-ful"] },
      { id: "C17S2", title: "C17S2: Prefixes ‚Äòre-‚Äô and ‚Äòdis-‚Äô", items: ["re-","dis-"] },
      { id: "C17S3", title: "C17S3: Comparative/ Superlative Suffixes ‚Äò-er‚Äô and ‚Äò-est‚Äô", items: ["-er","-est"] },

      { id: "C18S1", title: "C18S1: Prefix ‚Äòmis-‚Äô", items: ["mis-"] },
      { id: "C18S2", title: "C18S2: Prefix ‚Äòpre-‚Äô", items: ["pre-"] },
      { id: "C18S3", title: "C18S3: Suffix ‚Äò-less‚Äô", items: ["-less"] },
    ];

    const P_MAP = Object.create(null);
    const TITLE_MAP = Object.create(null);
    DB.forEach(s=>{
      P_MAP[s.id] = (s.items || []).slice();
      TITLE_MAP[s.id] = s.title || s.id;
    });

    const WORD_DB = {
      "C1S1": ["map","hot","bag","fix","sun","yes","hid","cut","box","dad","fun","hat","men","mud","nod","set","sit","tip"],
      "C1S2": ["shut","with","chat","ship","then","chop","that","moth","chip","rich","shop","shed","wish","they","thaw"],
      "C1S3": ["step","gram","flat","plan","skin","spot","plus","trip","bled","club","crab","flap","grin","plum","stop","twin"],

      "C2S1": ["fill","jazz","smell","miss","buzz","less","stuff","dress","huff","well","mess","toss","fuzz"],
      "C2S2": ["check","quick","rock","track","pick","black","pluck","clock","back","block","neck","pack","shock","smack","stick","stuck","thick","truck"],
      "C2S3": ["catch","pitch","clutch","hatch","snatch","match","fetch","stitch","blotch","ditch","hutch","patch","witch"],

      "C3S1": ["edge","lodge","judge","pledge","bridge","ledge","fridge","badge","fudge","hedge","nudge","ridge"],
      "C3S2": ["tube","note","theme","hope","five","shape","same","these","side","fine","hole","home","lake","nine","nose","pile","quake","shake","wide"],
      "C3S3": ["state","frog","shrug","cross","broke","grab","plane","stop","drop","drum","fled","plan","swim","slime","stone"],

      "C4S1": ["can","not","up","sun","cannot","sunset","upset","backpack","kidnap","pumpkin","on","nap","hotdog"],
      "C4S2": ["he","go","me","so","she","hero","halo","logo","solo","zero","be","no","we","veto"],
      "C4S3": ["picnic","hello","muffin","until","admit","rabbit","forbid","forget","mishap","submit"],

      "C5S1": ["tulip","habit","began","rapid","limit","robot","credit","finish","hotel","topic","unit","within"],
      "C5S2": ["problem","bottom","hidden","ago","human","minus","about","carrot","gallop","hundred"],
      "C5S3": ["must","suppose","object","himself","help","tadpole","cord","pond","sand","female","subject"],

      "C6S1": ["candle","tremble","paddle","crumble","able","table","middle","grumble","mumble","rumble","stable","stumble","cradle","fiddle"],
      "C6S2": ["apple","jiggle","kettle","smuggle","bottle","dimple","shuttle","wiggle","crumple","cripple","trample","battle","little","giggle","single"],
      "C6S3": ["far","garden","north","dark","sharp","popcorn","mark","short","platform","snarl","market","sparkle","forty","normal"],

      "C7S1": ["bird","turtle","corner","third","church","better","girl","burst","person","skirt","whirl","driver","surface","disturb"],
      "C7S2": ["dry","happy","family","fly","study","twenty","sky","cry","baby","my","any","tummy","fry","body","sly","filthy","try","silly"],
      "C7S3": ["stand","crispy","thirsty","spilt","subtract","starfish","print","plump","marble","brunch","spend","garlic","marker"],

      "C8S1": ["cent","city","digit","space","icy","magic","face","pencil","age","force","ice","place","rice","excite","decide","huge","large","digest"],
      "C8S2": ["away","wait","train","stay","maybe","obtain","play","friday","gain","pay","sway","today","brain","daisy"],
      "C8S3": ["railway","concert","gentle","circus","painter","birthday","crayon","circle","decay","mermaid","recess","celery"],

      "C9S1": ["green","feel","thirteen","seen","three","canteen","week","sleep","greedy","deep","feet","meet","speed","squeeze","teeth","beetle"],
      "C9S2": ["bread","heavy","reach","ready","least","treat","breath","heat","eagle","dead","clean","leapt","reason","healthy","increase","sea","steak","break","great"],
      "C9S3": ["cried","fried","field","lie","piece","shriek","pie","chief","shield","dried","flies","thief","belief"],

      "C10S1": ["vein","beige","protein","rein","seize","perceive","veil","caffeine","conceit","deceive","reindeer"],
      "C10S2": ["they","valley","kidney","obey","key","chimney","prey","grey","turkey","alley","hockey","jockey"],
      "C10S3": ["street","trolley","stream","strict","achieve","spread","sprint","convey","scrape","scrub","scramble","scribble","strain","strap","strike","stretcher","spree"],

      "C11S1": ["boat","float","window","load","grow","follow","groan","shown","yellow","roast","charcoal","upload","grown","below"],
      "C11S2": ["bookshelf","soon","scooter","took","food","raccoon","stood","room","noodle","cook","bloom","smooth","tooth"],
      "C11S3": ["true","flew","suitcase","clue","grew","juice","blue","threw","fruit","blueberry","untrue","brew","recruit"],

      "C12S1": ["value","stew","new","rescue","curfew","dew","argue","few","chew","hue","continue","mew","knew"],
      "C12S2": ["draw","law","straw","hawk","dawn","scrawny","saw","crawl","jigsaw","claw","jaw","lawn","prawn","thaw","seesaw"],
      "C12S3": ["strawberry","shadow","suitable","hollow","jewel","sailboat","pursue","shampoo","toaster","teaspoon","swimsuit","withdraw"],

      "C13S1": ["round","amount","town","without","sound","brown","ground","however","growl","count","found","house","frown","powder"],
      "C13S2": ["point","boy","oyster","voice","ploy","enjoy","soil","moist","cowboy","coin","appoint","toy","employ","destroy"],
      "C13S3": ["night","right","delight","fight","light","highlight","sight","bright","sunlight","flight","fright","might","thigh","tight","midnight"],

      "C14S1": ["knee","knot","knuckle","knife","knit","knock","known","knob","knight","know","kneel","knead","knockoff"],
      "C14S2": ["along","pink","blank","lung","morning","think","length","anything","clunk","song","spring","thing","riverbank"],
      "C14S3": ["kneecap","boomerang","blanket","highway","toilet","ceiling","fortnight","cloudy","outfit","towel","noisy","thankfully"],

      "C15S1": ["delay","afraid","weather","daytime","needle","leader","beyond","scramble","avenue","beaver","withdraw"],
      "C15S2": ["between","season","forfeit","jersey","sightsee","around","snowman","cartoon","barbecue","hideout","rescue"],
      "C15S3": ["elbow","footprint","chipmunk","onlooker","approach","penknife","allow","raincoat","marshmallow","outrank","ownership"],

      "C16S1": ["books","matches","benches","digits","nights","dishes","shapes","boxes","stamps","lunches","brushes","peaches"],
      "C16S2": ["crawled","reached","visited","played","picked","rested","walked","seized","baked","participated","charmed","worked","waited"],
      "C16S3": ["unscrew","incomplete","unhappy","incorrect","unlucky","unable","insane","unload","unjust","inaccurate"],

      "C17S1": ["singing","stressful","drawing","powerful","feeling","thankful","cooking","shouting","dreadful","helpful","painful"],
      "C17S2": ["rethink","reread","disbelief","redo","replayed","disobeying","reuse","disliked","restart","rewrite","reloading","disagree","disinfect","disabled"],
      "C17S3": ["brighter","brightest","greater","greatest","longer","longest","sharper","sharpest","stronger","strongest"],

      "C18S1": ["misuse","mistrust","mislead","misbehave","misplace","miscount","mismatch","misunderstand"],
      "C18S2": ["pretest","preview","prepaid","preheat","precook","premix","preconceive","precondition"],
      "C18S3": ["restless","harmless","homeless","helpless","hopeless","endless","useless","painless","speechless","spotless","powerless"]
    };

    function encodeWordItem(sid, word){ return `${sid}::${word}`; }
    function decodeWordItem(x){
      const s = String(x||'');
      const i = s.indexOf('::');
      if(i < 0) return { sid:'', word:s };
      return { sid: s.slice(0,i), word: s.slice(i+2) };
    }

    const HFW_SEED = {
      "C1S1": ["our"], "C1S2": ["ask"], "C1S3": ["work"],
      "C2S1": ["have","year"], "C2S2": ["give","only"], "C2S3": ["want","does"],
      "C3S1": ["here","more"], "C3S2": ["move","your"], "C3S3": ["some","come"],
      "C4S3": ["there"],
      "C5S1": ["where"], "C5S2": ["their"], "C5S3": ["great"],
      "C6S1": ["before","because"], "C6S2": ["after","would"], "C6S3": ["should","could"],
      "C7S1": ["mother","father"], "C7S2": ["through","learn"],
      "C8S1": ["own","hear","near"], "C8S2": ["above","school","eyes"], "C8S3": ["almost","always","most"],
      "C9S1": ["change","sometimes","something"], "C9S2": ["air","words","sentence"], "C9S3": ["second","four","fall"],
      "C10S1": ["people","aunt","uncle"], "C10S2": ["early","fast","last"], "C10S3": ["young","country","island"],
      "C11S1": ["earth","water","world"], "C11S2": ["questions","answer","sure"], "C11S3": ["money"],
      "C12S1": ["upon","once","both"], "C12S2": ["hours","minutes","figure"], "C12S3": ["done","brought","special"],
      "C13S1": ["half","equation","rule"], "C13S2": ["heard","friends","carefully"], "C13S3": ["nothing","enough","fire"],
      "C14S1": ["though","door","while"], "C14S2": ["group","material","idea"], "C14S3": ["language","clear","thought"]
    };

    function loadHfwDb(){
      try{
        const raw = localStorage.getItem(KEY_HFW_DB);
        return raw ? JSON.parse(raw) : {};
      }catch(e){ return {}; }
    }
    function saveHfwDb(db){
      try{ localStorage.setItem(KEY_HFW_DB, JSON.stringify(db)); }catch(e){}
    }
    let HFW_DB = loadHfwDb();
    (function seedHfwOnce(){
      let changed = false;
      for(const sid of Object.keys(HFW_SEED)){
        const seed = HFW_SEED[sid];
        if(!Array.isArray(seed) || !seed.length) continue;
        const curr = HFW_DB[sid];
        if(!Array.isArray(curr) || curr.length === 0){
          HFW_DB[sid] = seed.slice();
          changed = true;
        }
      }
      if(changed) saveHfwDb(HFW_DB);
    })();

    function loadRecords(){
      try{
        const raw = localStorage.getItem(KEY_RECORDS);
        return raw ? JSON.parse(raw) : [];
      }catch(e){ return []; }
    }
    function saveRecords(list){
      try{ localStorage.setItem(KEY_RECORDS, JSON.stringify(list)); }catch(e){}
    }
    let RECORDS = loadRecords();

    const soundToggle = document.getElementById('soundToggle');
    const soundLabel  = document.getElementById('soundLabel');
    let SOUND_ON = false;

    function loadChartOverrides(){
      try{
        const raw = localStorage.getItem(KEY_CHART_OVR);
        return raw ? JSON.parse(raw) : {};
      }catch(e){ return {}; }
    }
    function saveChartOverrides(obj){
      try{ localStorage.setItem(KEY_CHART_OVR, JSON.stringify(obj)); }catch(e){}
    }

    let CHART_OVR = loadChartOverrides();

    function cellKey(mode, sid){
      return `${mode}::${sid}`;
    }

    function isChartUnlocked(){
      try{ return localStorage.getItem(KEY_CHART_UNLOCK) === '1'; }catch(e){ return false; }
    }
    function setChartUnlocked(on){
      try{ localStorage.setItem(KEY_CHART_UNLOCK, on ? '1' : '0'); }catch(e){}
    }

    function getOverride(mode, cycle, session){
      const sid = makeSessionId(cycle, session);
      return CHART_OVR[cellKey(mode, sid)] || null;
    }
    function setOverride(mode, cycle, session, target, actual){
      const sid = makeSessionId(cycle, session);
      CHART_OVR[cellKey(mode, sid)] = {
        mode,
        sid,
        cycle,
        session,
        target: (target === '' || target == null) ? '' : Number(target),
        actual: (actual === '' || actual == null) ? '' : Number(actual),
        ts: Date.now()
      };
      saveChartOverrides(CHART_OVR);
    }
    function clearAllOverrides(){
      CHART_OVR = {};
      saveChartOverrides(CHART_OVR);
    }

    function setSound(on){
      SOUND_ON = !!on;
      soundToggle.classList.toggle('on', SOUND_ON);
      soundToggle.setAttribute('aria-checked', SOUND_ON ? 'true' : 'false');
      soundLabel.textContent = SOUND_ON ? 'Sound: ON' : 'Sound: OFF';
      try{ localStorage.setItem(KEY_SOUND, SOUND_ON ? '1':'0'); }catch(e){}
    }
    (function initSound(){
      let v = null;
      try{ v = localStorage.getItem(KEY_SOUND); }catch(e){}
      setSound(v === '1');
    })();

    function toggleSound(){ setSound(!SOUND_ON); }
    soundToggle.addEventListener('click', toggleSound);
    soundToggle.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleSound(); }
    });

    const AUDIO_BASE = 'audio/';
    const WORD_BASE  = 'audio/words/';
    const AUDIO_EXTS = ['mp3','m4a','mp4','wav','ogg'];
    const FILE_ALIASES = {};

    function sanitizePhonogramName(item){
      const raw = (FILE_ALIASES[item] ?? item);
      return String(raw).replace(/[^a-zA-Z0-9-]+/g,'');
    }
    function sanitizeWord(w){
      return String(w).toLowerCase().replace(/[^a-z]/g,'');
    }

    async function playViaPlayer(paths){
      const player = document.getElementById('player');
      for(const p of paths){
        try{
          player.pause();
          player.currentTime = 0;
          player.src = p;
          await player.play();
          return true;
        }catch(e){}
      }
      return false;
    }

    function speak(text){
      try{
        const synth = window.speechSynthesis;
        if(!synth) return;
        const utter = new SpeechSynthesisUtterance(String(text));
        utter.rate = 0.95;
        utter.pitch = 1.0;
        synth.cancel();
        synth.speak(utter);
      }catch(e){}
    }

    async function playPhonogramSound(item){
      const name = sanitizePhonogramName(item);
      const candidates = AUDIO_EXTS.map(ext => `${AUDIO_BASE}${name}.${ext}`);
      const ok = await playViaPlayer(candidates);
      if(!ok) speak(item);
    }

    async function playHfwSound(word){
      const name = sanitizeWord(word);
      const candidates = AUDIO_EXTS.map(ext => `${WORD_BASE}${name}.${ext}`);
      const ok = await playViaPlayer(candidates);
      if(!ok) speak(word);
    }

    let _timerCtx = null;

    async function unlockTimerBeep(){
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return;
        if(!_timerCtx) _timerCtx = new AC();
        if(_timerCtx.state === 'suspended') await _timerCtx.resume();
        const o = _timerCtx.createOscillator();
        const g = _timerCtx.createGain();
        g.gain.value = 0.00001;
        o.frequency.value = 440;
        o.connect(g); g.connect(_timerCtx.destination);
        o.start();
        o.stop(_timerCtx.currentTime + 0.02);
      }catch(e){}
    }

    function timerBeep(){
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return;
        if(!_timerCtx) _timerCtx = new AC();
        if(_timerCtx.state === 'suspended') _timerCtx.resume().catch(()=>{});

        const base = _timerCtx.currentTime;
        const pattern = [
          { start: 0.00, dur: 0.30, freq: 880 },
          { start: 0.45, dur: 0.30, freq: 988 },
          { start: 0.90, dur: 0.30, freq: 880 },
          { start: 1.60, dur: 0.30, freq: 880 },
          { start: 2.05, dur: 0.30, freq: 988 },
          { start: 2.50, dur: 0.30, freq: 880 },
        ];

        pattern.forEach(b=>{
          const o1 = _timerCtx.createOscillator();
          const g1 = _timerCtx.createGain();
          o1.type = 'sine';
          o1.frequency.value = b.freq;

          const o2 = _timerCtx.createOscillator();
          const g2 = _timerCtx.createGain();
          o2.type = 'triangle';
          o2.frequency.value = b.freq * 2;

          const t0 = base + b.start;
          const t1 = t0 + b.dur;

          g1.gain.setValueAtTime(0.0001, t0);
          g1.gain.exponentialRampToValueAtTime(0.28, t0 + 0.02);
          g1.gain.exponentialRampToValueAtTime(0.0001, t1);

          g2.gain.setValueAtTime(0.0001, t0);
          g2.gain.exponentialRampToValueAtTime(0.10, t0 + 0.02);
          g2.gain.exponentialRampToValueAtTime(0.0001, t1);

          o1.connect(g1); g1.connect(_timerCtx.destination);
          o2.connect(g2); g2.connect(_timerCtx.destination);

          o1.start(t0); o2.start(t0);
          o1.stop(t1);  o2.stop(t1);
        });
      }catch(e){}
    }

    const TEAM_PATTERNS = [
      "eigh","igh",
      "ai","ay","ee","ea","ie","ei","ey",
      "oa","ow","oo","ue","ew","ui",
      "aw","ou","ow","oi","oy"
    ];
    const R_CONTROLLED = ["ar","or","ir","er","ur"];

    const NOT_MAGIC_E = new Set([
      "have","give","live","love","done","gone","come","some","none","move","above"
    ]);

    function isVowelChar(ch){ return "aeiou".includes(ch); }
    function isLetter(ch){ return /^[a-z]$/i.test(ch); }

    function shouldMagicE(w){
      const s = String(w||'').toLowerCase();
      if(!s.endsWith('e')) return false;
      if(s.endsWith('le')) return false;
      if(NOT_MAGIC_E.has(s)) return false;
      if(s.length < 3) return false;
      const v = s[s.length-3];
      const c = s[s.length-2];
      if(!isVowelChar(v)) return false;
      if(isVowelChar(c)) return false;
      if(c === 'y') return false;
      return true;
    }

    function markAllPatterns(s, patterns, marks){
      const w = s.toLowerCase();
      patterns.forEach(pat=>{
        const L = pat.length;
        for(let i=0;i<=w.length-L;i++){
          if(w.slice(i, i+L) === pat){
            for(let k=0;k<L;k++) marks[i+k] = true;
          }
        }
      });
    }

    function markRControlled(s, marks){
      const w = s.toLowerCase();
      for(const pat of R_CONTROLLED){
        for(let i=0;i<=w.length-2;i++){
          if(w.slice(i,i+2) !== pat) continue;
          const after = w[i+2];
          if(after && isVowelChar(after)) continue;
          if(i === 0) continue;
          marks[i] = true;
          marks[i+1] = true;
        }
      }
    }

    function markConsonantLE(s, marks){
      const w = s.toLowerCase();
      if(w.length >= 3 && w.endsWith("le")){
        const thirdLast = w[w.length-3];
        if(!isVowelChar(thirdLast)){
          marks[w.length-1] = true;
        }
      }
    }

    function markMagicE(s, marks){
      const w = s.toLowerCase();
      if(!shouldMagicE(w)) return;
      const n = w.length;
      marks[n-3] = true;
      marks[n-1] = true;
    }

    function markOpenSyllableEnd(s, marks){
      const w = s.toLowerCase();
      for(let i = 0; i < w.length - 2; i++){
        if(isVowelChar(w[i]) && !isVowelChar(w[i+1]) && isVowelChar(w[i+2])){
          marks[i] = true;
        }
      }
      if(w.length >= 2 && !isVowelChar(w[w.length-2]) && isVowelChar(w[w.length-1])){
        marks[w.length-1] = true;
      }
    }

    function markYVowel(s, marks){
      const w = s.toLowerCase();
      for(let i=0;i<w.length;i++){
        if(w[i] !== 'y') continue;
        if(i === 0) continue;
        if(marks[i]) continue;
        const next = w[i+1];
        if(!next || !isVowelChar(next)){
          marks[i] = true;
        }
      }
    }

    /* ‚úÖ FIX: missing function was breaking Words of the Day (ReferenceError) */
    function markShortVowelsClosed(s, marks){
      const w = String(s||'').toLowerCase();

      // If it's a true magic-e word, do NOT force short vowel on the V in VCe
      const magicE = shouldMagicE(w);

      for(let i=0;i<w.length;i++){
        if(!isVowelChar(w[i])) continue;
        if(marks[i]) continue; // never override long/pattern marks

        // skip the long vowel in a magic-e pattern (V C e) -> the vowel is at n-3
        if(magicE && i === w.length - 3) continue;

        // closed syllable heuristic: vowel followed by consonant, and then
        // (end) or (another consonant). Example: c a t, h o t, f i x, b a g, s u n
        const n1 = w[i+1];
        if(!n1) continue;
        if(isVowelChar(n1)) continue;

        const n2 = w[i+2];
        if(!n2){
          marks[i] = true;
          continue;
        }
        if(!isVowelChar(n2)){
          marks[i] = true;
          continue;
        }
      }
    }

    const PREFIX_BY_SID = {
      "C16S3": ["un","in"],
      "C17S2": ["dis","re"],
      "C18S1": ["mis"],
      "C18S2": ["pre"]
    };
    const SUFFIX_BY_SID = {
      "C16S1": ["es","s"],
      "C16S2": ["ed"],
      "C17S1": ["ing","ful"],
      "C17S3": ["est","er"],
      "C18S3": ["less"]
    };

    function markPrefixBySid(w, sid, prefMarks){
      const s = w.toLowerCase();
      const list = (sid && PREFIX_BY_SID[sid]) ? PREFIX_BY_SID[sid] : [];
      const sorted = list.slice().sort((a,b)=>b.length-a.length);
      for(const pref of sorted){
        if(s.startsWith(pref) && s.length > pref.length){
          for(let i=0;i<pref.length;i++) prefMarks[i] = true;
          return;
        }
      }
    }

    function markSuffixBySid(w, sid, sufMarks){
      const s = w.toLowerCase();
      const list = (sid && SUFFIX_BY_SID[sid]) ? SUFFIX_BY_SID[sid] : [];
      const sorted = list.slice().sort((a,b)=>b.length-a.length);
      for(const suf of sorted){
        if(s.endsWith(suf) && s.length > suf.length){
          for(let i=s.length-suf.length;i<s.length;i++) sufMarks[i] = true;
          return;
        }
      }
    }

    function renderWordCoreHTML(word, sid){
      const s = String(word||'');
      const w = s.toLowerCase();

      const vowelMarks = new Array(s.length).fill(false);
      const prefMarks  = new Array(s.length).fill(false);
      const sufMarks   = new Array(s.length).fill(false);

      markAllPatterns(w, TEAM_PATTERNS, vowelMarks);
      markRControlled(w, vowelMarks);
      markMagicE(w, vowelMarks);
      markConsonantLE(w, vowelMarks);
      markOpenSyllableEnd(w, vowelMarks);
      markYVowel(w, vowelMarks);
      markShortVowelsClosed(w, vowelMarks);

      markPrefixBySid(w, sid, prefMarks);
      markSuffixBySid(w, sid, sufMarks);

      let out = '';
      for(let i=0;i<s.length;i++){
        const ch = s[i];
        if(ch === ' '){
          out += '<span class="sp"></span>';
          continue;
        }
        if(!isLetter(ch)){
          out += `<span class="cons">${ch}</span>`;
          continue;
        }

        let cls = 'cons';
        if(prefMarks[i])  cls = 'pre';
        if(sufMarks[i])   cls = 'suf';
        if(vowelMarks[i]) cls = 'vowel';
        out += `<span class="${cls}">${ch}</span>`;
      }
      return out;
    }

    function renderWordWithSidHTML(sid, word, small=false){
      const pillCls = small ? 'sidPill small' : 'sidPill';
      return `<span class="${pillCls}">${sid}</span>` + renderWordCoreHTML(word, sid);
    }

    function autoFitWordBox(el, minPx=18){
      if(!el) return;
      el.style.fontSize = '';
      requestAnimationFrame(()=>{
        const maxW = el.clientWidth;
        if(!maxW) return;
        let tries = 0;
        let fs = parseFloat(getComputedStyle(el).fontSize) || 48;
        while(tries < 6 && el.scrollWidth > (maxW - 6) && fs > minPx){
          const ratio = (maxW - 6) / el.scrollWidth;
          fs = Math.max(minPx, fs * ratio * 0.98);
          el.style.fontSize = fs.toFixed(2) + 'px';
          tries++;
        }
      });
    }

    const statusBadge = document.getElementById('statusBadge');

    const setupView   = document.getElementById('setupView');
    const dayView     = document.getElementById('dayView');
    const dashView    = document.getElementById('dashView');
    const resultView  = document.getElementById('resultView');
    const reviewView  = document.getElementById('reviewView');
    const remainingView = document.getElementById('remainingView');

    const modePBtn = document.getElementById('modeP');
    const modeHBtn = document.getElementById('modeH');
    const modeWBtn = document.getElementById('modeW');

    const hfwEditor = document.getElementById('hfwEditor');
    const wordsPanel = document.getElementById('wordsPanel');
    const wordsSidLabel = document.getElementById('wordsSidLabel');
    const wordsList = document.getElementById('wordsList');

   
    const cycleSel  = document.getElementById('cycleSel');
    const sessSel   = document.getElementById('sessSel');
    const scopeHint = document.getElementById('scopeHint');

    const hfwText = document.getElementById('hfwText');
    const hfwCountHint = document.getElementById('hfwCountHint');
    const saveHfwBtn = document.getElementById('saveHfwBtn');

    const targetInput = document.getElementById('targetInput');
    const autoTargetBtn = document.getElementById('autoTargetBtn');
    const targetHint = document.getElementById('targetHint');

    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');

    const chartWrap = document.getElementById('chartWrap');
    const historyHost = document.getElementById('historyHost');

    const btnPOD  = document.getElementById('btnPOD');
    const btnWOD  = document.getElementById('btnWOD');
    const btnHFWD = document.getElementById('btnHFWD');

    const backFromDay = document.getElementById('backFromDay');
    const dayTitle = document.getElementById('dayTitle');
    const daySub = document.getElementById('daySub');
    const dayBig = document.getElementById('dayBig');
    const dayPlayBtn = document.getElementById('dayPlayBtn');
    const dayPrevBtn = document.getElementById('dayPrevBtn');
    const dayNextBtn = document.getElementById('dayNextBtn');
    const dayCountHint = document.getElementById('dayCountHint');
    const dayAllTitle = document.getElementById('dayAllTitle');
    const dayAllHost = document.getElementById('dayAllHost');

    const fxOverlay = document.getElementById('fxOverlay');
    const fxTitle = document.getElementById('fxTitle');
    const fxSub = document.getElementById('fxSub');
    const confettiCanvas = document.getElementById('confettiCanvas');

    const timerTxt = document.getElementById('timerTxt');
    const dashItem = document.getElementById('dashItem');
    const dashMeta = document.getElementById('dashMeta');
    const dashProgress = document.getElementById('dashProgress');

    const kpiTarget = document.getElementById('kpiTarget');
    const kpiCorrect = document.getElementById('kpiCorrect');
    const kpiWrong = document.getElementById('kpiWrong');
    const kpiAttempted = document.getElementById('kpiAttempted');

    const yesBtn = document.getElementById('yesBtn');
    const noBtn  = document.getElementById('noBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const backSetupFromDash = document.getElementById('backSetupFromDash');

    const summaryLine = document.getElementById('summaryLine');
    const summaryMeta = document.getElementById('summaryMeta');
    const correctList = document.getElementById('correctList');
    const wrongList   = document.getElementById('wrongList');
    const remainList  = document.getElementById('remainList');

    const reviewWrongBtn = document.getElementById('reviewWrongBtn');
    const readRemainingBtn = document.getElementById('readRemainingBtn');
    const backSetupFromResult = document.getElementById('backSetupFromResult');

    const reviewGrid = document.getElementById('reviewGrid');
    const backToResultFromReview = document.getElementById('backToResultFromReview');
    const finishReviewBtn = document.getElementById('finishReviewBtn');

    const remainProg = document.getElementById('remainProg');
    const remainItem = document.getElementById('remainItem');
    const remainPlayBtn = document.getElementById('remainPlayBtn');
    const remainYesBtn = document.getElementById('remainYesBtn');
    const remainNoBtn  = document.getElementById('remainNoBtn');
    const backToResultFromRemaining = document.getElementById('backToResultFromRemaining');

    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    const clearHistoryBtn = document.getElementById('clearHistoryBtn');
    const newSessionBtn = document.getElementById('newSessionBtn');

    const unlockChartBtn = document.getElementById('unlockChartBtn');
    const lockChartBtn   = document.getElementById('lockChartBtn');
    const clearOverridesBtn = document.getElementById('clearOverridesBtn');

    let MODE = 'P';
let APP_MODE = 'DASH'; // 'DASH' | 'FOCUS'

const appDashBtn  = document.getElementById('appDashBtn');
const appFocusBtn = document.getElementById('appFocusBtn');

const dashOnly  = document.getElementById('dashOnly');
const focusOnly = document.getElementById('focusOnly');
const focusStartBtn = document.getElementById('focusStartBtn');

function setAppMode(m){
  APP_MODE = m;

  appDashBtn.classList.toggle('active', APP_MODE==='DASH');
  appFocusBtn.classList.toggle('active', APP_MODE==='FOCUS');

  if(dashOnly)  dashOnly.style.display  = (APP_MODE==='DASH') ? '' : 'none';
  if(focusOnly) focusOnly.style.display = (APP_MODE==='FOCUS') ? 'block' : 'none';

  // Default: One Minute Dash is randomised
  if(APP_MODE === 'DASH'){
    const r = document.querySelector('input[name="order"][value="random"]');
    if(r) r.checked = true;
    updateStartButtonLabel();
  }
}

appDashBtn.addEventListener('click', ()=> setAppMode('DASH'));
appFocusBtn.addEventListener('click', ()=> setAppMode('FOCUS'));

function selectedKindFromMode(){
  if(MODE === 'P') return 'P';
  if(MODE === 'HFW') return 'HFW';
  return 'W';
}

if(focusStartBtn){
  focusStartBtn.addEventListener('click', ()=>{
    // Launch Focus of the Day using the selected Category + current Cycle/Session
    openDay(selectedKindFromMode());
  });
}


    function getItemsForSession(sessionId){
      if(MODE === 'P') return (P_MAP[sessionId] || []);
      if(MODE === 'HFW'){
        const arr = (HFW_DB && HFW_DB[sessionId]) ? HFW_DB[sessionId] : [];
        return Array.isArray(arr) ? arr : [];
      }
      const arr = WORD_DB[sessionId] || [];
      return Array.isArray(arr) ? arr : [];
    }

    function setMode(m){
      MODE = m;
      modePBtn.classList.toggle('active', MODE==='P');
      modeHBtn.classList.toggle('active', MODE==='HFW');
      modeWBtn.classList.toggle('active', MODE==='W');

      hfwEditor.style.display = (MODE==='HFW') ? 'block' : 'none';
      wordsPanel.style.display = (MODE==='W') ? 'block' : 'none';

      targetInput.dataset.locked = '0';

     
      syncHfwEditor();
      syncWordsPanel();
      updateScopePreview(true);
      renderChart();
      renderHistory();
    }
    modePBtn.onclick = ()=> setMode('P');
    modeHBtn.onclick = ()=> setMode('HFW');
    modeWBtn.onclick = ()=> setMode('W');

    function isTimed(){
      const el = document.querySelector('input[name="timed"]:checked');
      return el ? (el.value === 'on') : true;
    }
    document.querySelectorAll('input[name="timed"]').forEach(r=>{
      r.addEventListener('change', ()=>{ updateStartButtonLabel(); });
    });

    function updateStartButtonLabel(){
      startBtn.textContent = isTimed() ? 'Start 60s Dash' : 'Start (untimed)';
    }

    function buildCycleSessionSelects(){
      cycleSel.innerHTML = '';
      for(let c=1;c<=TOTAL_CYCLES;c++){
        const opt = document.createElement('option');
        opt.value = String(c);
        opt.textContent = `Cycle ${c}`;
        cycleSel.appendChild(opt);
      }
      sessSel.innerHTML = '';
      for(let s=1;s<=SESSIONS_PER_CYCLE;s++){
        const opt = document.createElement('option');
        opt.value = String(s);
        opt.textContent = `Session ${s}`;
        sessSel.appendChild(opt);
      }
    }
    buildCycleSessionSelects();

    function currentSessionId(){
      const c = parseInt(cycleSel.value||'1',10);
      const s = parseInt(sessSel.value||'1',10);
      return makeSessionId(c,s);
    }

    
    

   
   cycleSel.addEventListener('change', ()=>{
  syncHfwEditor();
  syncWordsPanel();
  updateScopePreview(true);
});

    sessSel.addEventListener('change', ()=>{
  syncHfwEditor();
  syncWordsPanel();
  updateScopePreview(true);
});


    function parseWords(text){
      return String(text||'')
        .split(/[\n,]+/g)
        .map(s=>s.trim())
        .filter(Boolean);
    }

    function syncHfwEditor(){
      if(MODE !== 'HFW') return;
      const sid = currentSessionId();
      const arr = (HFW_DB[sid] && Array.isArray(HFW_DB[sid])) ? HFW_DB[sid] : [];
      hfwText.value = arr.join('\n');
      hfwCountHint.textContent = `${arr.length} words saved for ${sid}`;
    }

    saveHfwBtn.addEventListener('click', ()=>{
      const sid = currentSessionId();
      const words = parseWords(hfwText.value);
      HFW_DB[sid] = words;
      saveHfwDb(HFW_DB);
      hfwCountHint.textContent = `${words.length} words saved for ${sid}`;
      status(`Saved HFW list for ${sid} (${words.length} words).`);
      
      updateScopePreview(true);
      renderChart();
    });

    function syncWordsPanel(){
      if(MODE !== 'W') return;
      const sid = currentSessionId();
      wordsSidLabel.textContent = sid;

      const items = WORD_DB[sid] || [];
      wordsList.innerHTML = '';

      if(!items.length){
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent = 'No words for this session yet (you can add later).';
        wordsList.appendChild(p);
        return;
      }

      items.forEach(w=>{
        const row = document.createElement('div');
        row.className = 'wordRow';

        const btn = document.createElement('button');
        btn.className = 'btn ghost small';
        btn.type = 'button';
        btn.textContent = '‚ñ∂';
        btn.title = 'Play (TTS)';
        btn.onclick = ()=> speak(w);

        const text = document.createElement('div');
        text.className = 'wordText';
        text.innerHTML = renderWordWithSidHTML(sid, w, true);

        row.appendChild(btn);
        row.appendChild(text);
        wordsList.appendChild(row);
      });
    }

    function uniquePreserve(arr){
      const seen = new Set();
      const out = [];
      for(const x of arr){
        const k = String(x);
        if(seen.has(k)) continue;
        seen.add(k);
        out.push(x);
      }
      return out;
    }

    function buildScopeCumulative(upToId){
      const idx = SESSION_ORDER.indexOf(upToId);
      if(idx < 0) return [];
      const ids = SESSION_ORDER.slice(0, idx+1);
      const items = [];
      ids.forEach(sid=>{
        const list = getItemsForSession(sid);
        if(list && list.length) items.push(...list);
      });
      return uniquePreserve(items);
    }

    function buildScopeWords3(upToId){
      const idx = SESSION_ORDER.indexOf(upToId);
      if(idx < 0) return [];
      const start = Math.max(0, idx-2);
      const ids = SESSION_ORDER.slice(start, idx+1);
      const items = [];
      ids.forEach(sid=>{
        const list = WORD_DB[sid] || [];
        if(list && list.length){
          list.forEach(w => items.push(encodeWordItem(sid, w)));
        }
      });
      return uniquePreserve(items);
    }

    function buildScopePool(upToId){
      if(MODE === 'W') return buildScopeWords3(upToId);
      return buildScopeCumulative(upToId);
    }

    function scopeSummary(upToId, pool){
      const kind = (MODE === 'P') ? 'Phonograms' : (MODE === 'HFW') ? 'High Frequency Words' : 'Words';
      if(MODE === 'W'){
        const idx = SESSION_ORDER.indexOf(upToId);
        const start = Math.max(0, idx-2);
        const range = SESSION_ORDER.slice(start, idx+1);
        const from = range[0];
        const to = range[range.length-1];
        return `Scope (${kind}): ${from} ‚Üí ${to} (current + prev 2 sessions) | Items in scope: ${pool.length}`;
      }
      const title = TITLE_MAP[upToId] ? TITLE_MAP[upToId].replace(/^C\d+S\d+:\s*/,'') : '';
      const label = `${upToId}${title ? ' ‚Äî '+title : ''}`;
      return `Scope (${kind}): up to ${label} | Items in scope: ${pool.length}`;
    }

    function status(msg){
      statusBadge.style.display = 'block';
      statusBadge.textContent = msg;
      clearTimeout(status._t);
      status._t = setTimeout(()=>{ statusBadge.style.display='none'; }, 3500);
    }

    function updateScopePreview(autoTarget){
      const upToId = currentSessionId();
      const pool = buildScopePool(upToId);

      scopeHint.textContent = scopeSummary(upToId, pool);

      if(autoTarget){
        if(targetInput.dataset.locked !== '1'){
          targetInput.value = String(pool.length);
        }
      }

      const t = parseInt(targetInput.value||'0',10);
      targetHint.textContent = `Scope size = ${pool.length}. Target goal = ${isNaN(t)?0:t}.`;

      startBtn.classList.toggle('disabled', pool.length === 0);
      startBtn.disabled = (pool.length === 0);

      updateStartButtonLabel();
    }

    targetInput.addEventListener('input', ()=>{
      targetInput.dataset.locked = '1';
      updateScopePreview(false);
    });

    autoTargetBtn.addEventListener('click', ()=>{
      targetInput.dataset.locked = '0';
      updateScopePreview(true);
    });

    function getLatestByCell(mode, cycle, session){
      const sid = makeSessionId(cycle, session);
      const filtered = RECORDS.filter(r => r && r.timed === true && r.mode === mode && r.at === sid);
      if(!filtered.length) return null;
      filtered.sort((a,b)=> (b.t||0) - (a.t||0));
      return filtered[0];
    }

    function renderChart(){
      const unlocked = isChartUnlocked();

      const hint = document.getElementById('chartLockHint');
      const ub = document.getElementById('unlockChartBtn');
      const lb = document.getElementById('lockChartBtn');
      if(hint){
        hint.textContent = unlocked ? 'Chart: UNLOCKED (editing enabled)' : 'Chart: Locked (tap Unlock to edit)';
      }
      if(ub) ub.style.display = unlocked ? 'none' : '';
      if(lb) lb.style.display = unlocked ? '' : 'none';

      const table = document.createElement('table');

      const thead1 = document.createElement('tr');
      thead1.innerHTML = `
        <th rowspan="2" class="left">Cycle</th>
        <th rowspan="2">Type</th>
        <th colspan="2">Session 1</th>
        <th colspan="2">Session 2</th>
        <th colspan="2">Session 3</th>
      `;
      const thead2 = document.createElement('tr');
      thead2.innerHTML = `
        <th>Target</th><th>Actual</th>
        <th>Target</th><th>Actual</th>
        <th>Target</th><th>Actual</th>
      `;

      table.appendChild(thead1);
      table.appendChild(thead2);

      function valueForCell(mode, c, s){
        const ovr = getOverride(mode, c, s);
        if(ovr) return { target: ovr.target, actual: ovr.actual, source:'manual' };

        const rec = getLatestByCell(mode, c, s);
        if(rec) return { target: rec.target, actual: rec.correct, source:'auto' };

        return { target:'', actual:'', source:'none' };
      }

      function tdValue(v){
        if(v === '' || v == null || Number.isNaN(v)) return '<span class="mutedCell">‚Äî</span>';
        return String(v);
      }

      function mkInputCell(mode, c, s, field, val){
        const td = document.createElement('td');

        if(!unlocked){
          td.innerHTML = tdValue(val);
          return td;
        }

        const inp = document.createElement('input');
        inp.type = 'number';
        inp.min = '0';
        inp.value = (val === '' || val == null) ? '' : String(val);
        inp.style.width = '88px';
        inp.style.padding = '6px 8px';
        inp.style.borderRadius = '10px';
        inp.style.border = '1px solid var(--line)';
        inp.style.fontWeight = '900';
        inp.style.background = 'var(--paper)';
        inp.style.textAlign = 'center';

        inp.addEventListener('change', ()=>{
          const cur = valueForCell(mode, c, s);
          const newVal = inp.value === '' ? '' : Number(inp.value);
          const target = (field === 'target') ? newVal : cur.target;
          const actual = (field === 'actual') ? newVal : cur.actual;
          setOverride(mode, c, s, target, actual);
          status(`Saved manual chart edit: ${mode} ${makeSessionId(c,s)} (T=${target}, A=${actual})`);
          renderChart();
        });

        td.appendChild(inp);
        return td;
      }

      function buildRow(modeLabel, modeCode, c){
        const tr = document.createElement('tr');
        tr.innerHTML = (modeLabel === 'P')
          ? `<td class="left" rowspan="3"><b>Cycle ${c}</b></td><td class="typeCell">${modeLabel}</td>`
          : `<td class="typeCell">${modeLabel}</td>`;

        for(let s=1; s<=SESSIONS_PER_CYCLE; s++){
          const v = valueForCell(modeCode, c, s);
          tr.appendChild(mkInputCell(modeCode, c, s, 'target', v.target));
          tr.appendChild(mkInputCell(modeCode, c, s, 'actual', v.actual));
        }
        return tr;
      }

      for(let c=1;c<=TOTAL_CYCLES;c++){
        table.appendChild(buildRow('P', 'P', c));
        table.appendChild(buildRow('HFW', 'HFW', c));
        table.appendChild(buildRow('Words', 'W', c));
      }

      chartWrap.innerHTML = '';
      chartWrap.appendChild(table);
    }

    function fmtTime(ts){
      const d = new Date(ts);
      return d.toLocaleString();
    }

    function renderHistory(){
      historyHost.innerHTML = '';
      if(!RECORDS.length){
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent = 'No records yet. Run a dash and your results will appear here.';
        historyHost.appendChild(p);
        return;
      }

      const list = RECORDS.slice().sort((a,b)=> (b.t||0) - (a.t||0)).slice(0, 12);
      list.forEach(rec=>{
        const wrap = document.createElement('div');
        wrap.className = 'histItem';

        const left = document.createElement('div');
        const title = document.createElement('div');
        const modeLabel = (rec.mode === 'P') ? 'P' : (rec.mode === 'HFW') ? 'HFW' : 'Words';
        const timedLabel = rec.timed ? 'Timed' : 'Untimed';
        title.innerHTML = `<b>${modeLabel} ¬∑ ${rec.at}</b> ‚Äî ${timedLabel} ‚Äî Target ${rec.target} ¬∑ Actual ${rec.correct}`;
        const small = document.createElement('small');
        small.textContent = `${fmtTime(rec.t)} ¬∑ Attempted ${rec.attempted}/${rec.scopeSize} ¬∑ Wrong ${rec.wrong?.length||0} ¬∑ Remaining ${rec.remaining?.length||0}`;
        left.appendChild(title);
        left.appendChild(small);

        const right = document.createElement('div');
        right.className = 'rightSide';

        const btn = document.createElement('button');
        btn.className = 'btn ghost small';
        btn.type = 'button';
        btn.textContent = 'View';
        btn.onclick = ()=> showRecordDetails(rec);
        right.appendChild(btn);

        wrap.appendChild(left);
        wrap.appendChild(right);
        historyHost.appendChild(wrap);
      });
    }

    function pillList(hostEl, items, cls, mode){
      hostEl.innerHTML = '';
      (items || []).forEach(x=>{
        const p = document.createElement('div');
        p.className = `pill ${cls||'neutral'}`;
        if(mode === 'W'){
          const d = decodeWordItem(x);
          p.innerHTML = renderWordWithSidHTML(d.sid, d.word, true);
        } else {
          p.textContent = x;
        }
        hostEl.appendChild(p);
      });
    }

    let LAST_RESULT = null;

    function showRecordDetails(rec){
      LAST_RESULT = rec;
      const modeLabel = (rec.mode === 'P') ? 'Phonograms' : (rec.mode === 'HFW') ? 'High Frequency Words' : 'Words';
      const timedLabel = rec.timed ? 'Timed' : 'Untimed';
      summaryLine.textContent = `${modeLabel} ¬∑ ${rec.at} ‚Äî ${timedLabel} ‚Äî Actual ${rec.correct} / Target ${rec.target}`;
      summaryMeta.textContent = `Order: ${rec.order} ¬∑ Attempted: ${rec.attempted}/${rec.scopeSize} ¬∑ Wrong: ${rec.wrong.length} ¬∑ Remaining: ${rec.remaining.length} ¬∑ ${fmtTime(rec.t)}`;
      pillList(correctList, rec.correctList, 'good', rec.mode);
      pillList(wrongList, rec.wrong, 'bad', rec.mode);
      pillList(remainList, rec.remaining, 'neutral', rec.mode);
      switchView('result');
    }

    function switchView(name){
      [setupView, dayView, dashView, resultView, reviewView, remainingView].forEach(v=>v.classList.remove('active'));
      if(name==='setup') setupView.classList.add('active');
      if(name==='day') dayView.classList.add('active');
      if(name==='dash') dashView.classList.add('active');
      if(name==='result') resultView.classList.add('active');
      if(name==='review') reviewView.classList.add('active');
      if(name==='remaining') remainingView.classList.add('active');
      window.scrollTo({top:0, behavior:'smooth'});
    }

    function showFx(title, sub){
      fxTitle.textContent = title || 'Drumroll‚Ä¶';
      fxSub.textContent = sub || 'Get ready! üéâ';
      fxOverlay.style.display = 'grid';
      confettiCanvas.style.display = 'block';
    }
    function hideFx(){
      fxOverlay.style.display = 'none';
      confettiCanvas.style.display = 'none';
    }

    function runConfetti(durationMs=1400){
      const c = confettiCanvas;
      const ctx = c.getContext('2d');
      const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      function resize(){
        c.width = Math.floor(window.innerWidth * DPR);
        c.height = Math.floor(window.innerHeight * DPR);
      }
      resize();

      const colors = ['#2563eb','#16a34a','#e11d48','#d97706','#0ea5e9','#7c3aed','#f43f5e','#22c55e'];
      const N = 140;
      const parts = [];
      for(let i=0;i<N;i++){
        parts.push({
          x: Math.random()*c.width,
          y: -Math.random()*c.height*0.3,
          vx: (Math.random()*2-1) * 220,
          vy: 200 + Math.random()*520,
          r: 4 + Math.random()*6,
          rot: Math.random()*Math.PI,
          vr: (Math.random()*2-1)*6,
          col: colors[(Math.random()*colors.length)|0],
          shape: Math.random() < 0.5 ? 'rect' : 'circ'
        });
      }

      const t0 = performance.now();
      let raf = 0;

      function step(t){
        const dt = Math.min(0.033, (t - (step._t || t))/1000);
        step._t = t;

        ctx.clearRect(0,0,c.width,c.height);

        for(const p of parts){
          p.vy += 380*dt;
          p.x += p.vx*dt;
          p.y += p.vy*dt;
          p.rot += p.vr*dt;

          if(p.x < -50) p.x = c.width + 50;
          if(p.x > c.width + 50) p.x = -50;

          ctx.fillStyle = p.col;
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          if(p.shape === 'rect'){
            ctx.fillRect(-p.r, -p.r*0.6, p.r*2, p.r*1.2);
          } else {
            ctx.beginPath();
            ctx.arc(0,0,p.r,0,Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }

        if(t - t0 < durationMs){
          raf = requestAnimationFrame(step);
        } else {
          cancelAnimationFrame(raf);
          ctx.clearRect(0,0,c.width,c.height);
        }
      }
      raf = requestAnimationFrame(step);

      window.addEventListener('resize', resize, { once:true });
    }

    async function playDrumroll(durationMs=1200){
      if(!SOUND_ON) return;
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return;
        if(!_timerCtx) _timerCtx = new AC();
        if(_timerCtx.state === 'suspended') await _timerCtx.resume();

        const ctx = _timerCtx;
        const now = ctx.currentTime;

        const bufferSize = Math.floor(ctx.sampleRate * 0.25);
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1);

        const src = ctx.createBufferSource();
        src.buffer = noiseBuffer;
        src.loop = true;

        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 140;
        filter.Q.value = 0.8;

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, now);

        src.connect(filter);
        filter.connect(g);
        g.connect(ctx.destination);

        src.start(now);

        const steps = 18;
        for(let i=0;i<steps;i++){
          const t = now + (i/steps)*(durationMs/1000);
         const amp = 0.5 + (i/steps)*2; // VERY loud

          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(amp, t + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
          filter.frequency.setValueAtTime(140 + i*10, t);
        }

        const endT = now + durationMs/1000;
        g.gain.setValueAtTime(g.gain.value, endT);
        g.gain.exponentialRampToValueAtTime(0.0001, endT + 0.10);

        src.stop(endT + 0.14);
      }catch(e){}
    }

    async function fxBurst(title, sub, ms=1400){
      showFx(title, sub);
      runConfetti(ms);
      await playDrumroll(Math.min(1200, ms));
      await new Promise(r=>setTimeout(r, ms));
      hideFx();
    }

    let DAY = null;

    function getDayList(kind, sid){
      if(kind === 'P') return (P_MAP[sid] || []).slice();
      if(kind === 'W') return (WORD_DB[sid] || []).slice();
      const curr = (HFW_DB && Array.isArray(HFW_DB[sid])) ? HFW_DB[sid] : [];
      const seed = (HFW_SEED && Array.isArray(HFW_SEED[sid])) ? HFW_SEED[sid] : [];
      return (curr.length ? curr : seed).slice();
    }

    function kindLabel(kind){
      if(kind === 'P') return 'Phonogram of the Day';
      if(kind === 'W') return 'Words of the Day';
      return 'High Frequency Words of the Day';
    }

    function renderDayAll(kind, sid, list){
      dayAllHost.innerHTML = '';

      if(kind === 'W'){
        const wrap = document.createElement('div');
        wrap.className = 'wordsList';

        list.forEach(w=>{
          const row = document.createElement('div');
          row.className = 'wordRow';

          const btn = document.createElement('button');
          btn.className = 'btn ghost small';
          btn.type = 'button';
          btn.textContent = '‚ñ∂';
          btn.title = 'Play (TTS)';
          btn.onclick = ()=> speak(w);

          const text = document.createElement('div');
          text.className = 'wordText';
          text.innerHTML = renderWordCoreHTML(w, sid);

          row.appendChild(btn);
          row.appendChild(text);
          wrap.appendChild(row);
        });

        dayAllHost.appendChild(wrap);
        return;
      }

      const pillRow = document.createElement('div');
      pillRow.className = 'pillRow';
      pillRow.style.justifyContent = 'center';

      list.forEach(x=>{
        const p = document.createElement('div');
        p.className = 'pill neutral';
        p.textContent = x;
        pillRow.appendChild(p);
      });

      dayAllHost.appendChild(pillRow);
    }

    function showDayItem(){
      if(!DAY) return;
      const it = DAY.list[DAY.idx] ?? '';
      const sid = DAY.sid;

      dayCountHint.textContent = `Item ${DAY.idx+1} of ${DAY.list.length} ‚Ä¢ ${sid}`;

      if(DAY.kind === 'W'){
        dayBig.classList.add('hasSid');
        dayBig.innerHTML = renderWordWithSidHTML(sid, it, false);
        autoFitWordBox(dayBig, 22);
      } else {
        dayBig.classList.remove('hasSid');
        dayBig.style.fontSize = '';
        dayBig.textContent = it || '‚Äî';
      }
    }

    function playDayItem(){
      if(!DAY) return;
      const it = DAY.list[DAY.idx];
      if(!it) return;

      if(DAY.kind === 'P') playPhonogramSound(it);
      else if(DAY.kind === 'HFW') playHfwSound(it);
      else speak(it);
    }

    async function openDay(kind){
      const sid = currentSessionId();
      const list = getDayList(kind, sid);

      if(!list.length){
        alert(`No items found for ${kindLabel(kind)} at ${sid}.`);
        return;
      }

      DAY = { kind, sid, list, idx: 0 };

      dayTitle.textContent = kindLabel(kind);
      daySub.textContent = sid;
      dayAllTitle.textContent = `All items ‚Äî ${sid}`;

      renderDayAll(kind, sid, list);
      showDayItem();

      switchView('day');
      await fxBurst('Drumroll‚Ä¶', `Revealing ${kindLabel(kind)} ‚Ä¢ ${sid}`, 1400);
      dayNextBtn.focus({ preventScroll:true });
    }

   if(btnPOD)  btnPOD.addEventListener('click', ()=> openDay('P'));
if(btnWOD)  btnWOD.addEventListener('click', ()=> openDay('W'));
if(btnHFWD) btnHFWD.addEventListener('click', ()=> openDay('HFW'));


    dayNextBtn.addEventListener('click', ()=>{
      if(!DAY) return;
      DAY.idx = (DAY.idx + 1) % DAY.list.length;
      showDayItem();
    });
    dayPrevBtn.addEventListener('click', ()=>{
      if(!DAY) return;
      DAY.idx = (DAY.idx - 1 + DAY.list.length) % DAY.list.length;
      showDayItem();
    });
    dayPlayBtn.addEventListener('click', playDayItem);
    backFromDay.addEventListener('click', ()=> switchView('setup'));

    const DASH_SECONDS = 60;
    let DASH = null;
    let tickId = 0;
    let paused = false;
    let pauseStartedAt = 0;

    function mmss(sec){
      const s = Math.max(0, sec|0);
      const m = Math.floor(s/60);
      const r = s % 60;
      return String(m).padStart(2,'0') + ':' + String(r).padStart(2,'0');
    }

    function getOrder(){
      const el = document.querySelector('input[name="order"]:checked');
      return el ? el.value : 'sequence';
    }

    function shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function readableListForFeedback(mode, arr){
      if(mode !== 'W') return (arr||[]).join(', ');
      return (arr||[]).map(x=>decodeWordItem(x).word).join(', ');
    }

    function buildFeedback(rec){
      const wrong = rec.wrong.length ? readableListForFeedback(rec.mode, rec.wrong) : '(none)';
      const remaining = rec.remaining.length ? readableListForFeedback(rec.mode, rec.remaining) : '(none)';
      return [
        `OMD ${rec.mode}`,
        `At ${rec.at}`,
        rec.timed ? `Timed 60s` : `Untimed`,
        `Target ${rec.target}`,
        `Actual ${rec.correct}/${rec.scopeSize} (attempted ${rec.attempted})`,
        `Wrong: ${wrong}`,
        `Remaining: ${remaining}`
      ].join(' | ');
    }

    function currentItem(){
      return DASH && DASH.pool && DASH.pool[DASH.idx];
    }

    function showDashItem(){
      const it = currentItem();
      if(!it){
        dashItem.textContent = '‚Äî';
        dashProgress.textContent = '‚Äî';
        return;
      }

      if(DASH.mode === 'W'){
        dashItem.classList.add('hasSid');
        const d = decodeWordItem(it);
        dashItem.innerHTML = renderWordWithSidHTML(d.sid, d.word, false);
        autoFitWordBox(dashItem, 22);
      } else {
        dashItem.classList.remove('hasSid');
        dashItem.style.fontSize = '';
        dashItem.textContent = it;
      }

      const modeLabel = (DASH.mode === 'P') ? 'Phonograms' : (DASH.mode === 'HFW') ? 'High Frequency Words' : 'Words';
      dashMeta.textContent = `${modeLabel} ¬∑ Selected: ${DASH.at} ¬∑ Scope size ${DASH.scopeSize} ¬∑ ${DASH.order === 'random' ? 'Randomised' : 'Sequence'} ¬∑ ${DASH.timed ? 'Timed 60s' : 'Untimed'}`;
      dashProgress.textContent = `Item ${Math.min(DASH.idx+1, DASH.scopeSize)} of ${DASH.scopeSize}`;

      if(SOUND_ON){
        if(DASH.mode === 'P') playPhonogramSound(it);
        else if(DASH.mode === 'HFW') playHfwSound(it);
        else speak(decodeWordItem(it).word);
      }
    }

    function updateKpi(){
      const attempted = DASH.correctList.length + DASH.wrong.length;
      kpiTarget.textContent = String(DASH.target);
      kpiCorrect.textContent = String(DASH.correctList.length);
      kpiWrong.textContent = String(DASH.wrong.length);
      kpiAttempted.textContent = String(attempted);
    }

    function stopTick(){
      if(tickId) clearInterval(tickId);
      tickId = 0;
    }

    function finishDash(timeUp){
      stopTick();

      if(DASH && DASH.timed){
        try{ timerBeep(); }catch(e){}
      }

      paused = false;
      pauseBtn.textContent = 'Pause';

      const attempted = DASH.correctList.length + DASH.wrong.length;
      const remaining = DASH.pool.slice(DASH.idx);

      const rec = {
        id: 'rec_' + Math.random().toString(16).slice(2) + '_' + Date.now(),
        t: Date.now(),
        mode: DASH.mode,
        at: DASH.at,
        cycle: parseSessionId(DASH.at).cycle,
        session: parseSessionId(DASH.at).session,
        target: DASH.target,
        order: DASH.order,
        duration: DASH.timed ? DASH_SECONDS : null,
        timed: !!DASH.timed,
        scopeSize: DASH.scopeSize,
        attempted,
        correct: DASH.correctList.length,
        correctList: DASH.correctList.slice(),
        wrong: DASH.wrong.slice(),
        remaining: remaining.slice(),
      };

      RECORDS.push(rec);
      saveRecords(RECORDS);

      if(rec.timed){
        const feedback = buildFeedback(rec);
        pushToXAPI(rec.correct, feedback);
      }

      LAST_RESULT = rec;

      const modeLabel = (rec.mode === 'P') ? 'Phonograms' : (rec.mode === 'HFW') ? 'High Frequency Words' : 'Words';
      summaryLine.textContent = `${modeLabel} ¬∑ ${rec.at} ‚Äî ${rec.timed ? 'Timed' : 'Untimed'} ‚Äî Actual ${rec.correct} / Target ${rec.target}${rec.timed ? (timeUp ? ' (Time up)' : ' (Completed)') : ''}`;
      summaryMeta.textContent = `Attempted: ${rec.attempted}/${rec.scopeSize} ¬∑ Wrong: ${rec.wrong.length} ¬∑ Remaining: ${rec.remaining.length} ¬∑ Order: ${rec.order} ¬∑ ${fmtTime(rec.t)}`;
      pillList(correctList, rec.correctList, 'good', rec.mode);
      pillList(wrongList, rec.wrong, 'bad', rec.mode);
      pillList(remainList, rec.remaining, 'neutral', rec.mode);

      renderChart();
      renderHistory();
      status(`Saved record: ${rec.at} ¬∑ ${rec.timed ? 'Timed' : 'Untimed'} ¬∑ Target ${rec.target} ¬∑ Actual ${rec.correct}`);

      switchView('result');
    }

    function tick(){
      if(!DASH || !DASH.timed) return;
      if(paused) return;

      const now = Date.now();
      const msLeft = DASH.endsAt - now;
      const secLeft = Math.max(0, Math.ceil(msLeft/1000));

      timerTxt.textContent = mmss(secLeft);
      timerTxt.classList.toggle('soon', secLeft <= 10 && secLeft > 0);
      timerTxt.classList.toggle('zero', secLeft === 0);

      if(secLeft <= 0){
        finishDash(true);
      }
    }

    function startDash(){
      unlockTimerBeep();

      const at = currentSessionId();
      const pool0 = buildScopePool(at);
      if(!pool0.length){
        alert('No items in scope yet. Choose a session that has items (or add HFW words).');
        return;
      }

      const order = getOrder();
      const pool = (order === 'random') ? shuffle(pool0) : pool0.slice();

      let target = parseInt(targetInput.value||'0',10);
      if(!Number.isFinite(target) || target < 0) target = pool.length;

      const timed = isTimed();

      DASH = {
        mode: MODE,
        at,
        order,
        pool,
        scopeSize: pool.length,
        target,
        idx: 0,
        correctList: [],
        wrong: [],
        timed,
        startedAt: Date.now(),
        endsAt: timed ? (Date.now() + DASH_SECONDS*1000) : Infinity,
      };
      paused = false;
      pauseStartedAt = 0;

      updateKpi();
      showDashItem();

      if(timed){
        timerTxt.textContent = mmss(DASH_SECONDS);
        timerTxt.classList.remove('soon','zero');
        pauseBtn.style.display = '';
        pauseBtn.disabled = false;
      } else {
        timerTxt.textContent = 'No Timer';
        timerTxt.classList.remove('soon','zero');
        pauseBtn.style.display = 'none';
      }

      yesBtn.disabled = false;
      noBtn.disabled  = false;

      switchView('dash');

      stopTick();
      if(timed){
        tickId = setInterval(tick, 200);
        tick();
      }

      statusBadge.style.display = 'block';
      const modeLabel = (DASH.mode === 'P') ? 'P' : (DASH.mode === 'HFW') ? 'HFW' : 'Words';
      statusBadge.textContent = `${modeLabel} ¬∑ ${DASH.at} ¬∑ Scope ${DASH.scopeSize} ¬∑ Target ${DASH.target} ¬∑ ${timed ? 'Timed' : 'Untimed'}`;
    }

    function answer(correct){
      if(!DASH) return;
      const it = currentItem();
      if(!it) return;

      if(correct) DASH.correctList.push(it);
      else DASH.wrong.push(it);

      DASH.idx++;
      updateKpi();

      if(DASH.idx >= DASH.scopeSize){
        finishDash(false);
        return;
      }
      showDashItem();
    }

    yesBtn.addEventListener('click', ()=> answer(true));
    noBtn.addEventListener('click',  ()=> answer(false));
    playBtn.addEventListener('click', ()=>{
      if(!DASH) return;
      const it = currentItem();
      if(!it) return;
      if(DASH.mode === 'P') playPhonogramSound(it);
      else if(DASH.mode === 'HFW') playHfwSound(it);
      else speak(decodeWordItem(it).word);
    });

    pauseBtn.addEventListener('click', ()=>{
      if(!DASH || !DASH.timed) return;
      paused = !paused;
      if(paused){
        pauseBtn.textContent = 'Resume';
        pauseStartedAt = Date.now();
        status('Paused.');
      } else {
        pauseBtn.textContent = 'Pause';
        const pausedMs = Date.now() - pauseStartedAt;
        DASH.endsAt += pausedMs;
        status('Resumed.');
      }
    });

    backSetupFromDash.addEventListener('click', ()=>{
      const go = confirm('Go back to setup? This dash will be cancelled.');
      if(!go) return;
      stopTick();
      DASH = null;
      paused = false;
      pauseBtn.textContent = 'Pause';
      switchView('setup');
    });

    backSetupFromResult.addEventListener('click', ()=> switchView('setup'));

    reviewWrongBtn.addEventListener('click', ()=>{
      if(!LAST_RESULT) return;
      if(!LAST_RESULT.wrong || !LAST_RESULT.wrong.length){
        alert('No wrong items to review. Great job!');
        return;
      }
      openReview(LAST_RESULT);
    });

    function openReview(rec){
      reviewGrid.innerHTML = '';

      rec.wrong.forEach(item=>{
        const card = document.createElement('div');
        card.className = 'review-card';

        const big = document.createElement('div');
        big.className = 'bigItem';
        if(rec.mode === 'W'){
          const d = decodeWordItem(item);
          big.classList.add('hasSid');
          big.innerHTML = renderWordWithSidHTML(d.sid, d.word, false);
        } else {
          big.textContent = item;
        }

        const row = document.createElement('div');
        row.className = 'row-small';
        row.style.justifyContent = 'center';

        const btnMain = document.createElement('button');
        btnMain.className = 'btn small';
        btnMain.style.background = '#06b6d4';
        btnMain.textContent = 'üîä Play';
        btnMain.onclick = ()=>{
          if(rec.mode === 'P') playPhonogramSound(item);
          else if(rec.mode === 'HFW') playHfwSound(item);
          else speak(decodeWordItem(item).word);
        };

        row.appendChild(btnMain);

        const markBtn = document.createElement('button');
        markBtn.className = 'btn ok small';
        markBtn.textContent = '‚úì Mark as reviewed';
        markBtn.onclick = ()=>{ markBtn.disabled = true; markBtn.textContent = 'Reviewed'; };

        card.appendChild(big);
        card.appendChild(row);
        card.appendChild(markBtn);

        reviewGrid.appendChild(card);

        if(rec.mode === 'W'){
          autoFitWordBox(big, 18);
        }
      });

      switchView('review');
    }

    backToResultFromReview.addEventListener('click', ()=> switchView('result'));
    finishReviewBtn.addEventListener('click', ()=>{
      alert('Review completed. You can continue with remaining items or start a new dash.');
      switchView('result');
    });

    let REMAIN = null;

    function startRemaining(rec){
      const list = (rec && rec.remaining) ? rec.remaining.slice() : [];
      if(!list.length){
        alert('No remaining items. Well done!');
        return;
      }
      REMAIN = {
        mode: rec.mode,
        at: rec.at,
        list,
        idx: 0,
        extraWrong: []
      };
      showRemainingItem();
      switchView('remaining');
    }

    function showRemainingItem(){
      const it = REMAIN.list[REMAIN.idx];
      if(REMAIN.mode === 'W'){
        const d = decodeWordItem(it);
        remainItem.classList.add('hasSid');
        remainItem.innerHTML = renderWordWithSidHTML(d.sid, d.word, false);
        autoFitWordBox(remainItem, 22);
      } else {
        remainItem.classList.remove('hasSid');
        remainItem.style.fontSize = '';
        remainItem.textContent = it || '‚Äî';
      }
      remainProg.textContent = `Item ${Math.min(REMAIN.idx+1, REMAIN.list.length)} / ${REMAIN.list.length}`;
      if(SOUND_ON && it){
        if(REMAIN.mode === 'P') playPhonogramSound(it);
        else if(REMAIN.mode === 'HFW') playHfwSound(it);
        else speak(decodeWordItem(it).word);
      }
    }

    function remainNext(markWrong){
      const it = REMAIN.list[REMAIN.idx];
      if(it && markWrong) REMAIN.extraWrong.push(it);
      REMAIN.idx++;
      if(REMAIN.idx >= REMAIN.list.length){
        const msg = REMAIN.extraWrong.length
          ? `Done. Extra wrong items during remaining: ${REMAIN.extraWrong.map(x=>decodeWordItem(x).word).join(', ')}`
          : 'Done. No extra wrong items during remaining.';
        alert(msg);
        switchView('result');
        return;
      }
      showRemainingItem();
    }

    readRemainingBtn.addEventListener('click', ()=>{
      if(!LAST_RESULT) return;
      startRemaining(LAST_RESULT);
    });

    remainPlayBtn.addEventListener('click', ()=>{
      if(!REMAIN) return;
      const it = REMAIN.list[REMAIN.idx];
      if(!it) return;
      if(REMAIN.mode === 'P') playPhonogramSound(it);
      else if(REMAIN.mode === 'HFW') playHfwSound(it);
      else speak(decodeWordItem(it).word);
    });

    remainYesBtn.addEventListener('click', ()=> remainNext(false));
    remainNoBtn.addEventListener('click', ()=> remainNext(true));
    backToResultFromRemaining.addEventListener('click', ()=> switchView('result'));

    function downloadJSON(obj, filename){
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    exportBtn.addEventListener('click', ()=>{
      const snapshot = {};
      for(let c=1;c<=TOTAL_CYCLES;c++){
        for(let s=1;s<=SESSIONS_PER_CYCLE;s++){
          const sid = makeSessionId(c,s);
          snapshot[sid] = snapshot[sid] || {};
          ['P','HFW','W'].forEach(mode=>{
            const ovr = getOverride(mode, c, s);
            const rec = getLatestByCell(mode, c, s);
            snapshot[sid][mode] = {
              target: ovr ? ovr.target : (rec ? rec.target : ''),
              actual: ovr ? ovr.actual : (rec ? rec.correct : ''),
              source: ovr ? 'manual' : (rec ? 'auto' : 'none')
            };
          });
        }
      }

      const payload = {
        exportedAt: new Date().toISOString(),
        records: RECORDS,
        hfwDb: HFW_DB,
        chartOverrides: CHART_OVR,
        chartSnapshot: snapshot
      };
      downloadJSON(payload, `one-minute-dash-records-${Date.now()}.json`);
    });

    importBtn.addEventListener('click', ()=> importFile.click());

    importFile.addEventListener('change', async ()=>{
      const file = importFile.files && importFile.files[0];
      importFile.value = '';
      if(!file) return;

      try{
        const text = await file.text();
        const obj = JSON.parse(text);

        const incomingRecords = Array.isArray(obj.records) ? obj.records : [];
        const incomingHfw = (obj.hfwDb && typeof obj.hfwDb === 'object') ? obj.hfwDb : {};
        const incomingOverrides = (obj.chartOverrides && typeof obj.chartOverrides === 'object') ? obj.chartOverrides : null;

        const byId = new Map(RECORDS.map(r=> [r.id, r]));
        incomingRecords.forEach(r=>{
          if(r && r.id) byId.set(r.id, r);
          else RECORDS.push(r);
        });
        RECORDS = Array.from(byId.values()).filter(Boolean);
        saveRecords(RECORDS);

        HFW_DB = { ...(HFW_DB||{}), ...(incomingHfw||{}) };
        saveHfwDb(HFW_DB);

        if(incomingOverrides){
          CHART_OVR = { ...(CHART_OVR||{}), ...(incomingOverrides||{}) };
          saveChartOverrides(CHART_OVR);
        }

        status('Imported JSON successfully.');
       
        syncHfwEditor();
        syncWordsPanel();
        updateScopePreview(true);
        renderChart();
        renderHistory();
      }catch(e){
        alert('Import failed. Please ensure this is a valid JSON exported from One Minute Dash.');
      }
    });

    clearHistoryBtn.addEventListener('click', ()=>{
      const ok = confirm('Clear ALL One Minute Dash records (history) on this browser? This cannot be undone.\n\nTip: Download JSON first if you want backup.');
      if(!ok) return;
      RECORDS = [];
      saveRecords(RECORDS);
      status('History cleared.');
      renderChart();
      renderHistory();
    });

    if(unlockChartBtn){
      unlockChartBtn.addEventListener('click', ()=>{
        const pw = prompt('Enter password to unlock chart editing:');
        if(pw === '0000'){
          setChartUnlocked(true);
          status('Chart unlocked. You can edit targets/actuals directly in the table.');
          renderChart();
        } else {
          alert('Wrong password.');
        }
      });
    }
    if(lockChartBtn){
      lockChartBtn.addEventListener('click', ()=>{
        setChartUnlocked(false);
        status('Chart locked.');
        renderChart();
      });
    }
    if(clearOverridesBtn){
      clearOverridesBtn.addEventListener('click', ()=>{
        const ok = confirm('Clear ALL manual chart edits? (Auto values from timed records will still remain.)');
        if(!ok) return;
        clearAllOverrides();
        status('Manual chart edits cleared.');
        renderChart();
      });
    }

    resetBtn.addEventListener('click', ()=>{
      const ok = confirm('Reset target lock and refresh scope preview?');
      if(!ok) return;
      targetInput.dataset.locked = '0';
      updateScopePreview(true);
    });

    newSessionBtn.addEventListener('click', ()=>{
      try{
        pushToXAPI(0, '');
        status('SLS attempt cleared (score/feedback set to 0). OMD history kept.');
      }catch(e){}
    });

    startBtn.addEventListener('click', ()=>{
  if(APP_MODE === 'FOCUS'){
    openDay(selectedKindFromMode());
    return;
  }
  startDash();
});


   function init(){
  syncHfwEditor();
  syncWordsPanel();
  updateScopePreview(true);
  renderChart();
  renderHistory();
  updateStartButtonLabel();

  // Default mode: One Minute Dash (randomised)
  setAppMode('DASH');
}


    init();

    window.addEventListener('load', () => {
      NewSessionClearKit.init({
        activityId: window.ACTIVITY_ID,
        clickButtonId: 'newSessionBtn',
        pushZero: false
      });
    });
  })();
  </script>
</body>
</html>
